def merge_vertical_conditionnel(ws, col_idx, df_col, start_row, group_col=None):
    """
    Fusion verticale des cellules identiques dans une colonne.
    Si group_col est fourni, fusion seulement si la valeur du groupe est identique.
    """
    if len(df_col) == 0:
        return
    current_val = df_col.iloc[0]
    current_group = group_col.iloc[0] if group_col is not None else None
    start_idx = 0
    for i in range(1, len(df_col)):
        val = df_col.iloc[i]
        group_val = group_col.iloc[i] if group_col is not None else None
        same = (val == current_val) and (group_col is None or group_val == current_group)
        if not same:
            if i - 1 > start_idx:
                ws.merge_cells(start_row=start_row + start_idx, start_column=col_idx,
                               end_row=start_row + i - 1, end_column=col_idx)
            start_idx = i
            current_val = val
            current_group = group_val
    # fusion de la dernière série
    if len(df_col) - 1 > start_idx:
        ws.merge_cells(start_row=start_row + start_idx, start_column=col_idx,
                       end_row=start_row + len(df_col) - 1, end_column=col_idx)


def draw_border_lines_for_tim_blocks(ws, start_row, df_sorted, first_col, last_col, site_col_idx=None):
    """
    Trace des bordures horizontales : 
    - haut et bas pour chaque TIM
    - ligne supplémentaire entre sites si site_col_idx fourni
    """
    thin = Side(border_style="thin", color="000000")
    top_border = Border(top=thin)
    bottom_border = Border(bottom=thin)

    # Bordures TIM
    tim_groups = df_sorted.groupby("TIM").apply(lambda x: (x.index.min(), x.index.max()))
    for tim, (start_idx, end_idx) in tim_groups.items():
        top_row = start_row + start_idx
        bottom_row = start_row + end_idx
        for c in range(first_col, last_col + 1):
            ws.cell(row=top_row, column=c).border = Border(
                left=ws.cell(row=top_row, column=c).border.left,
                right=ws.cell(row=top_row, column=c).border.right,
                top=thin,
                bottom=ws.cell(row=top_row, column=c).border.bottom
            )
            ws.cell(row=bottom_row, column=c).border = Border(
                left=ws.cell(row=bottom_row, column=c).border.left,
                right=ws.cell(row=bottom_row, column=c).border.right,
                top=ws.cell(row=bottom_row, column=c).border.top,
                bottom=thin
            )

    # Bordures entre sites
    if site_col_idx is not None:
        for i in range(1, len(df_sorted)):
            if df_sorted["SITE"].iloc[i] != df_sorted["SITE"].iloc[i - 1]:
                row = start_row + i
                for c in range(first_col, last_col + 1):
                    ws.cell(row=row, column=c).border = Border(
                        left=ws.cell(row=row, column=c).border.left,
                        right=ws.cell(row=row, column=c).border.right,
                        top=thin,
                        bottom=ws.cell(row=row, column=c).border.bottom
                    )


def apply_uma_exceptions(df_patron):
    """
    Gère les exceptions UMA spécifiques :
    - 150 HTD : RUM codés TIM = 0 (codés par cliniciens)
    - 040X CCH : transféré de codés à relancés
    - 561C, 591C, 591J CCH : codés par TIM, non cliniciens
    """
    # UMA 150 HTD
    mask_150 = (df_patron["UMA_code"] == "150") & (df_patron["SITE"] == "HTD") & (df_patron["UMA_type"] == "HC")
    df_patron.loc[mask_150, ["RUM_codes_mois", "RUM_codes_cum"]] = 0.0

    # UMA 040X CCH : transférer des codés aux relancés
    mask_040X = (df_patron["UMA_code"].str.startswith("040X")) & (df_patron["SITE"] == "CCH")
    df_patron.loc[mask_040X, ["RUM_rel_mois", "RUM_rel_cum"]] = df_patron.loc[mask_040X, ["RUM_codes_mois", "RUM_codes_cum"]].values
    df_patron.loc[mask_040X, ["RUM_codes_mois", "RUM_codes_cum"]] = 0.0

    # UMA 561C, 591C, 591J CCH : codés par TIM
    for uma in ["561C", "591C", "591J"]:
        mask = (df_patron["UMA_code"] == uma) & (df_patron["SITE"] == "CCH") & (df_patron["UMA_type"] == "HDJ")
        df_patron.loc[mask, ["RUM_codes_mois", "RUM_codes_cum"]] = df_patron.loc[mask, ["RUM_rel_mois", "RUM_rel_cum"]].values
        df_patron.loc[mask, ["RUM_rel_mois", "RUM_rel_cum"]] = 0.0

    return df_patron


def write_copy_with_values_to_patron(df, patron_path):
    """
    Écrit le dataframe dans le patron Excel et retourne un BytesIO pour téléchargement Streamlit
    """
    from io import BytesIO
    copy_path = patron_path  # pas besoin de copier sur disque
    wb = load_workbook(filename=str(copy_path))
    ws = wb.active

    # repérer header_row
    header_row = None
    for r in range(1, 30):
        values = [(ws.cell(row=r, column=c).value or "").strip().lower() for c in range(1, ws.max_column + 1)]
        if "tim" in values and "site" in values:
            header_row = r
            break
    if not header_row:
        header_row = 1

    # mapping des en-têtes
    name_to_col = {str(ws.cell(row=header_row, column=c).value).strip().lower(): c
                   for c in range(1, ws.max_column + 1) if ws.cell(row=header_row, column=c).value}

    # assignation colonnes
    col_tim = name_to_col.get("tim")
    col_site = name_to_col.get("site")
    col_uma_hc = name_to_col.get("uma hc")
    col_rum_codes_mois = name_to_col.get("rum codes mois")
    col_rum_codes_cum = name_to_col.get("rum codes cumul")
    col_uma_hdj = name_to_col.get("uma hdj")
    col_dmu = name_to_col.get("dmu")
    col_rum_rel_mois = name_to_col.get("rum rel mois")
    col_rum_rel_cum = name_to_col.get("rum rel cum")

    start = header_row + 1

    df_sorted = df.sort_values(by=["TIM", "SITE", "DMU", "UMA_code"]).reset_index(drop=True)

    for idx, row in df_sorted.iterrows():
        excel_row = start + idx
        ws.cell(row=excel_row, column=col_tim).value = row["TIM"]
        ws.cell(row=excel_row, column=col_site).value = row["SITE"]
        if row["UMA_type"] == "HC":
            ws.cell(row=excel_row, column=col_uma_hc).value = row["UMA_libelle"]
            ws.cell(row=excel_row, column=col_rum_codes_mois).value = int(round(row["RUM_codes_mois"]))
            ws.cell(row=excel_row, column=col_rum_codes_cum).value = int(round(row["RUM_codes_cum"]))
        else:
            ws.cell(row=excel_row, column=col_uma_hdj).value = row["UMA_libelle"]
            ws.cell(row=excel_row, column=col_dmu).value = row["DMU"]
            ws.cell(row=excel_row, column=col_rum_rel_mois).value = int(round(row["RUM_rel_mois"]))
            ws.cell(row=excel_row, column=col_rum_rel_cum).value = int(round(row["RUM_rel_cum"]))

    # Fusion TIM / SITE / DMU
    merge_vertical_conditionnel(ws, col_tim, df_sorted["TIM"], start)
    merge_vertical_conditionnel(ws, col_site, df_sorted["SITE"], start, group_col=df_sorted["TIM"])
    merge_vertical_conditionnel(ws, col_dmu, df_sorted["DMU"], start, group_col=df_sorted["TIM"])

    # Bordures
    draw_border_lines_for_tim_blocks(ws, start, df_sorted, 1, ws.max_column, site_col_idx=col_site)

    # Align center
    for idx, row in df_sorted.iterrows():
        excel_row = start + idx
        for c in [col_tim, col_site, col_dmu]:
            ws.cell(row=excel_row, column=c).alignment = Alignment(horizontal="center", vertical="center")

    # TIM bold
    tim_positions = df_sorted.groupby("TIM").apply(lambda x: (x.index.min(), x.index.max()))
    for tim, (start_idx, _) in tim_positions.items():
        excel_row = start + start_idx
        ws.cell(row=excel_row, column=col_tim).font = Font(bold=True)

    # exporter en mémoire
    output = BytesIO()
    wb.save(output)
    output.seek(0)
    return output
