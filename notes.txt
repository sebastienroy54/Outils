import streamlit as st
import pandas as pd
import re
from io import BytesIO
import openpyxl
import subprocess
from pathlib import Path
import time
from datetime import datetime

# =========================================================
# PATHS PORTABLES
# =========================================================

BASE_DIR = Path(__file__).resolve().parents[1]   # Portail_outils
DATA_DIR = BASE_DIR / "data"
SQL_DIR = BASE_DIR / "SQL"

TEST_SQL_PATH = SQL_DIR / "test_connexion.sql"
FUSION_PATH = DATA_DIR / "Fusion_excel.xlsx"
CSV_PATH = DATA_DIR / "BHRe.csv"

SQL_BASE = SQL_DIR / "BHRe.sql"
SQL_TEMP = SQL_DIR / "BHRe_temp.sql"

# =========================================================
# OUTILS
# =========================================================

def safe_show_exception(e):
    st.error("Une erreur est survenue. V√©rifiez vos fichiers ou contactez le support.")
    if st.checkbox("Afficher d√©tails techniques"):
        st.exception(e)

def normaliser_texte(val):
    if val is None:
        return ""
    return str(val).strip().lower().replace("\n", " ")

# =========================================================
# EXCEL HELPERS
# =========================================================

def trouver_feuille_avec_colonnes(fichier, colonnes_attendues, max_scan=50, debug=False):
    fichier.seek(0)
    wb = openpyxl.load_workbook(fichier, data_only=True)
    colonnes_norm = [normaliser_texte(c) for c in colonnes_attendues]

    for sheetname in wb.sheetnames:
        fichier.seek(0)
        df = pd.read_excel(fichier, sheet_name=sheetname, header=None, dtype=str)
        if debug:
            st.write(f"--- FEUILLE : {sheetname} ---")
            st.write(df.head())
        for i in range(min(len(df), max_scan)):
            row_norm = [normaliser_texte(x) for x in df.iloc[i].tolist()]
            if any("=" in str(x) for x in row_norm):
                continue
            if sum(x not in ["", "none", "nan"] for x in row_norm) < 2:
                continue
            if all(col in row_norm for col in colonnes_norm):
                fichier.seek(0)
                df_final = pd.read_excel(
                    fichier,
                    sheet_name=sheetname,
                    header=i,
                    dtype=str
                )
                return df_final, sheetname, i

    raise ValueError(f"Aucune feuille ne contient les colonnes {colonnes_attendues}")

def nettoyer_ipp(val):
    if val is None:
        return ""
    val = re.sub(r"\D", "", str(val))
    return val[-10:] if len(val) >= 10 else ""

def fusion_excel(df1, df2, df3):
    for df in [df1, df2, df3]:
        df.columns = [normaliser_texte(c) for c in df.columns]

    df1 = df1.rename(columns={"c": "nom", "pr√©nom": "prenom"})
    df2 = df2.rename(columns={"nom": "nom", "pr√©nom": "prenom", "ddn": "ddn", "nip": "ipp"})
    df3 = df3.rename(columns={"nom": "nom", "pr√©nom": "prenom", "ddn": "ddn", "ipp": "ipp"})

    for df in [df1, df2, df3]:
        for col in ["nom", "prenom"]:
            df[col] = df[col].astype(str).str.strip().str.upper()

    df2["ipp"] = df2["ipp"].apply(nettoyer_ipp)
    df3["ipp"] = df3["ipp"].apply(nettoyer_ipp)

    ref = pd.concat([df2, df3], ignore_index=True)
    ref = ref.drop_duplicates(subset=["nom", "prenom", "ipp"])

    df_merge = df1.merge(ref, on=["nom", "prenom"], how="inner")
    df_merge["ddn"] = pd.to_datetime(df_merge["ddn"], errors="coerce", dayfirst=True)
    df_merge["ddn"] = df_merge["ddn"].dt.strftime("%d/%m/%Y")
    return df_merge.sort_values("nom")[["nom", "prenom", "ddn", "ipp"]]

def generer_excel(df):
    output = BytesIO()
    with pd.ExcelWriter(output, engine="openpyxl") as writer:
        df.to_excel(writer, index=False, sheet_name="Croisement")
    return output.getvalue()

# =========================================================
# STREAMLIT APP
# =========================================================

def main():
    st.title("Croisement Fichiers Excel BHRe")

    if "oracle_connected" not in st.session_state:
        st.session_state.oracle_connected = False

    # ----------------- CONNEXION ORACLE -----------------

    if not st.session_state.oracle_connected:
        with st.form("connexion"):
            user = st.text_input("üë§ Nom d'utilisateur Oracle")
            password = st.text_input("üîë Mot de passe", type="password")
            submitted = st.form_submit_button("üöÄ Se connecter")

        if submitted:
            TEST_SQL_PATH.write_text("select 1 from dual;\nexit;", encoding="utf-8")
            tns_alias = "SIP1CCH.WORLD"
            cmd = f"sqlplus -S {user}/{password}@{tns_alias} @{TEST_SQL_PATH}"

            proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, text=True)
            start = time.time()
            output = ""
            while True:
                if proc.poll() is not None:
                    output += proc.communicate()[0]
                    break
                if time.time() - start > 3:
                    proc.kill()
                    st.error("Timeout connexion Oracle")
                    return
                time.sleep(0.1)

            if "1" in output:
                st.session_state.oracle_user = user
                st.session_state.oracle_password = password
                st.session_state.oracle_connected = True
                st.rerun()
            else:
                st.error("Connexion √©chou√©e")
        return

    # ----------------- UPLOAD FILES -----------------

    fichier1 = st.file_uploader("Fichier Indicateur (F1)", type=["xlsx"])
    fichier2 = st.file_uploader("Fichier Suivi Termin√© (F2)", type=["xlsx"])
    fichier3 = st.file_uploader("Fichier Suivi (F3)", type=["xlsx"])
    debug = st.checkbox("Mode debug")

    if fichier1 and fichier2 and fichier3:
        try:
            df1, _, _ = trouver_feuille_avec_colonnes(fichier1, ["c", "pr√©nom"], debug=debug)
            df2, _, _ = trouver_feuille_avec_colonnes(fichier2, ["nom", "pr√©nom", "ddn", "nip"], debug=debug)
            df3, _, _ = trouver_feuille_avec_colonnes(fichier3, ["nom", "pr√©nom", "ddn", "ipp"], debug=debug)

            df_result = fusion_excel(df1, df2, df3)

            FUSION_PATH.write_bytes(generer_excel(df_result))

            annee = datetime.now().year
            ipps_txt = ",".join(f"'{ipp}'" for ipp in df_result["ipp"].dropna().unique())

            sql_final = (
                SQL_BASE.read_text(encoding="utf-8")
                .replace("--IPP_PLACEHOLDER--", ipps_txt)
                .replace("--ANNEE_SQL--", str(annee))
            )
            SQL_TEMP.write_text(sql_final, encoding="utf-8")

            tns_alias = "SIP1CCH.WORLD"
            subprocess.run(
                f"sqlplus {st.session_state.oracle_user}/{st.session_state.oracle_password}@{tns_alias} @{SQL_TEMP}",
                shell=True
            )

            df_csv = pd.read_csv(CSV_PATH, sep=";", header=None, dtype=str)
            df_csv.columns = ["IPP", "NDA", "GHM", "DUREE_SEJOUR"]

            excel_final = DATA_DIR / f"BHRe_{annee}.xlsx"
            df_csv.to_excel(excel_final, index=False)
            CSV_PATH.unlink(missing_ok=True)

            st.download_button(
                "üíæ T√©l√©charger BHRe",
                excel_final.read_bytes(),
                file_name=excel_final.name,
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )

        except Exception as e:
            safe_show_exception(e)

if __name__ == "__main__":
    main()
