import streamlit as st
import pandas as pd
from io import BytesIO
from openpyxl.styles import Font, Alignment, PatternFill
from openpyxl.utils import get_column_letter

# -----------------------
# Helpers
# -----------------------
def safe_show_exception(e):
    """Affiche un message utilisateur simple et propose d'afficher le dÃ©tail technique."""
    st.error("Une erreur est survenue pendant le traitement. Veuillez vÃ©rifier vos fichiers ou contacter le support.")
    if st.checkbox("Afficher les dÃ©tails techniques (pour un dÃ©veloppeur)"):
        st.exception(e)

def lire_fichier_excel(fichier, widget_label="fichier"):
    """Lit un fichier Excel et renvoie (annee, data, meta).
       LÃ¨ve une exception en cas de problÃ¨me -> gÃ©rÃ© par l'appelant.
    """
    try:
        df = pd.read_excel(fichier, header=None)
    except Exception as e:
        raise RuntimeError(f"Impossible de lire le {widget_label} : le fichier n'est pas un Excel lisible.") from e

    try:
        # mÃ©tadonnÃ©es
        resume_filtrage = df.iloc[3, 0]
        periode = str(df.iloc[4, 0])
        filtres = df.iloc[5, 0]
        detail_valo = df.iloc[7, 0]

        # extraire annÃ©e depuis la ligne de pÃ©riode
        import re
        match = re.search(r"(\d{4})", periode)
        annee = match.group(1) if match else "XXXX"

        # lire le tableau Ã  partir de la ligne 9 (index 8)
        data = pd.read_excel(fichier, header=8)
        data = data.iloc[:, :4]
        data.columns = ["Indicateur", "Valorisation", "QuantitÃ©", "UnitÃ©"]
    except Exception as e:
        raise RuntimeError("Le format du fichier Excel ne correspond pas au modÃ¨le attendu (vÃ©rifier les lignes d'en-tÃªte et la structure).") from e

    return annee, data, {
        "RÃ©sumÃ© de filtrage": resume_filtrage,
        "PÃ©riode": periode,
        "Filtres": filtres,
        "DÃ©tail valorisation": detail_valo
    }

def creer_tableau_comparatif(df_new, annee_new, df_old, annee_old):
    """Fusionne en gardant l'ordre df_new (le plus rÃ©cent)."""
    try:
        df_new = df_new.rename(columns={
            "Valorisation": f"Valorisation {annee_new}",
            "QuantitÃ©": f"QuantitÃ© {annee_new}",
            "UnitÃ©": f"UnitÃ© {annee_new}"
        })
        df_old = df_old.rename(columns={
            "Valorisation": f"Valorisation {annee_old}",
            "QuantitÃ©": f"QuantitÃ© {annee_old}",
            "UnitÃ©": f"UnitÃ© {annee_old}"
        })

        # merge en gardant l'ordre de df_new (left join)
        df_merge = df_new.merge(df_old, on="Indicateur", how="left", sort=False)

        # supprimer colonne vide intermÃ©diaire (on n'en crÃ©e pas)
        df_merge[f"Ã‰cart Valorisation ({annee_new}-{annee_old})"] = (
            df_merge.get(f"Valorisation {annee_new}", pd.Series(dtype=float)).fillna(0) -
            df_merge.get(f"Valorisation {annee_old}", pd.Series(dtype=float)).fillna(0)
        )

    except Exception as e:
        raise RuntimeError("Erreur lors de la crÃ©ation du tableau comparatif.") from e

    return df_merge

def format_valeur_monetaire_cell(val):
    """Retourne chaÃ®ne formatÃ©e: 1 234 567 â‚¬ ou vide si NaN."""
    try:
        if pd.isna(val) or val == "":
            return ""
        v = float(val)
        # format 0 dÃ©cimales, espace comme sÃ©parateur de milliers, virgule pour dÃ©cimales si besoin
        s = f"{v:,.0f}".replace(",", " ")
        return f"{s} â‚¬"
    except:
        return val

def generer_excel(df, annee_new, annee_old):
    """GÃ©nÃ¨re un fichier Excel stylisÃ© et renvoie BytesIO."""
    try:
        output = BytesIO()
        titre = f"Comparatif {annee_new} vs {annee_old}"

        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            # Ã©crire le df Ã  partir de la ligne 2 (ligne 1 = titre)
            df.to_excel(writer, index=False, sheet_name="Comparatif", startrow=1)
            wb = writer.book
            ws = wb["Comparatif"]

            # titre
            ws.cell(row=1, column=1, value=titre)
            ws.cell(row=1, column=1).font = Font(size=14, bold=True)
            last_col_idx = df.shape[1]
            ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=last_col_idx)
            ws.cell(row=1, column=1).alignment = Alignment(horizontal="center")

            # style header (ligne 2)
            header_fill = PatternFill(start_color="D9D9D9", end_color="D9D9D9", fill_type="solid")
            for cell in ws[2]:
                cell.font = Font(bold=True)
                cell.fill = header_fill
                cell.alignment = Alignment(horizontal="center")

            # identifier colonnes de valorisation et d'Ã©cart
            valorisation_cols_idx = [i+1 for i, c in enumerate(df.columns) if "Valorisation" in c]
            ecart_col_idx = None
            for i, c in enumerate(df.columns, start=1):
                if "Ã‰cart Valorisation" in c:
                    ecart_col_idx = i
                    break
            if ecart_col_idx and ecart_col_idx not in valorisation_cols_idx:
                valorisation_cols_idx.append(ecart_col_idx)

            # Formater les cellules de valorisation : mettre en forme texte "1 000 000 â‚¬" et rouge si nÃ©gatif
            for row in range(3, len(df) + 3):  # donnÃ©es commencent Ã  la 3Ã¨me ligne
                for col_idx in valorisation_cols_idx:
                    cell = ws.cell(row=row, column=col_idx)
                    try:
                        raw_val = cell.value
                        if raw_val is None or raw_val == "":
                            cell.value = ""
                            continue
                        val_float = float(raw_val)
                        cell.value = format_valeur_monetaire_cell(val_float)
                        # si nÃ©gatif -> texte rouge
                        if val_float < 0:
                            cell.font = Font(color="FF0000")
                    except Exception:
                        # si la conversion Ã©choue, on laisse la valeur telle quelle (texte)
                        pass

            # Ajustement largeur colonnes (utiliser get_column_letter pour Ã©viter problÃ¨me MergedCell)
            for idx in range(1, last_col_idx + 1):
                col_letter = get_column_letter(idx)
                max_length = 0
                for cell in ws[col_letter]:
                    if cell.value is not None:
                        max_length = max(max_length, len(str(cell.value)))
                ws.column_dimensions[col_letter].width = max_length + 2

        output.seek(0)
        return output

    except Exception as e:
        raise RuntimeError("Impossible de gÃ©nÃ©rer le fichier Excel.") from e

def afficher_tableau_colore(df, annee_new, annee_old):
    """Affiche le tableau dans Streamlit (format monÃ©taire et texte rouge pour nÃ©gatifs)."""
    try:
        valorisation_cols = [c for c in df.columns if "Valorisation" in c or "Ã‰cart Valorisation" in c]

        # PrÃ©parer une copie pour affichage avec format monÃ©taire
        df_styled = df.copy()
        for col in valorisation_cols:
            def fmt(v):
                try:
                    if pd.isna(v) or v == "":
                        return ""
                    return format_valeur_monetaire_cell(float(v))
                except:
                    return v
            df_styled[col] = df_styled[col].apply(fmt)

        # fonction pour colorer en rouge si la valeur numÃ©rique sous-jacente est nÃ©gative
        def color_neg(v):
            try:
                # essayer d'extraire un nombre depuis la chaÃ®ne (ex: "1 234 â‚¬")
                if isinstance(v, str):
                    s = v.replace("â‚¬", "").replace(" ", "").replace(",", ".").strip()
                    val = float(s) if s != "" else 0.0
                else:
                    val = float(v)
                return 'color: red' if val < 0 else ''
            except:
                return ''

        st.markdown(f"### ðŸ“Š Comparatif {annee_new} vs {annee_old}")
        st.dataframe(df_styled.style.applymap(color_neg, subset=valorisation_cols))

    except Exception as e:
        raise RuntimeError("Erreur lors de l'affichage du tableau.") from e

# -----------------------
# main()
# -----------------------
def main():
    st.title("ðŸ’¶ Comparateur de Valorisation T2A")

    st.write("### ðŸ—‚ï¸ Importez les deux fichiers Excel (respecter le modÃ¨le de fichier)")
    fichier1 = st.file_uploader("Fichier rÃ©cent (ex: 2025)", type=["xlsx"], key="file1")
    fichier2 = st.file_uploader("Fichier ancien (ex: 2024)", type=["xlsx"], key="file2")

    if not (fichier1 and fichier2):
        st.info("Veuillez uploader les deux fichiers pour comparer.")
        return

    # Optionnel : bouton pour lancer le traitement (Ã©vite double exÃ©cution pendant l'upload)
    if not st.button("Lancer la comparaison"):
        return

    # Traitement global encadrÃ© d'un try pour afficher message utilisateur en cas d'erreur
    try:
        annee1, df1, meta1 = lire_fichier_excel(fichier1, widget_label="premier fichier")
        annee2, df2, meta2 = lire_fichier_excel(fichier2, widget_label="deuxiÃ¨me fichier")

        # Si les annÃ©es sont inversÃ©es (on veut annee1 >= annee2), on swap
        try:
            if int(annee1) < int(annee2):
                st.info(f"Inversion dÃ©tectÃ©e : {annee1} < {annee2}. Les fichiers seront rÃ©ordonnÃ©s automatiquement.")
                # swap
                annee1, annee2 = annee2, annee1
                df1, df2 = df2, df1
        except Exception:
            # si on ne peut pas caster en int, on continue sans swap automatique
            st.warning("Impossible de dÃ©terminer l'ordre des annÃ©es automatiquement (format de la pÃ©riode inattendu). VÃ©rifiez les pÃ©riodes dans vos fichiers.")

        st.write("### ðŸ§¾ MÃ©tadonnÃ©es")
        st.write(f"**PÃ©riode {annee1} :** {meta1.get('PÃ©riode','')}")
        st.write(f"**PÃ©riode {annee2} :** {meta2.get('PÃ©riode','')}")

        # crÃ©ation comparatif
        df_comparatif = creer_tableau_comparatif(df1, annee1, df2, annee2)

        # affichage
        afficher_tableau_colore(df_comparatif, annee1, annee2)

        # gÃ©nÃ©ration excel et bouton de tÃ©lÃ©chargement
        excel_data = generer_excel(df_comparatif, annee1, annee2)
        st.download_button(
            label="ðŸ’¾ TÃ©lÃ©charger le comparatif (Excel)",
            data=excel_data,
            file_name=f"Comparatif_{annee1}_{annee2}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )

    except Exception as e:
        # message convivial + option pour voir le dÃ©tail complet
        safe_show_exception(e)

# ExÃ©cutable directement
if __name__ == "__main__":
    main()
