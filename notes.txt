import streamlit as st
import pandas as pd
import numpy as np
import re
from io import BytesIO
import openpyxl

# -------------------------
# OUTILS
# -------------------------

def safe_show_exception(e):
    st.error("Une erreur est survenue. V√©rifiez vos fichiers ou contactez le support.")
    if st.checkbox("Afficher d√©tails techniques"):
        st.exception(e)

def normaliser_texte(val):
    if val is None:
        return ""
    return str(val).strip().lower().replace("\n", " ")

# D√©tection dynamique de la bonne feuille + de la ligne d‚Äôen-t√™te
def trouver_feuille_avec_colonnes(fichier, colonnes_attendues, max_scan=50):
    wb = openpyxl.load_workbook(fichier, data_only=True)
    colonnes_norm = [normaliser_texte(c) for c in colonnes_attendues]

    for sheetname in wb.sheetnames:
        df = pd.read_excel(fichier, sheet_name=sheetname, header=None, dtype=str, engine="openpyxl")

        # Scanner les premi√®res lignes
        for i in range(min(len(df), max_scan)):
            row = df.iloc[i].tolist()
            row_norm = [normaliser_texte(x) for x in row]

            if all(c in row_norm for c in colonnes_norm):
                # Ret√©l√©charger proprement avec header fix√©
                df_final = pd.read_excel(fichier, sheet_name=sheetname, header=i, dtype=str, engine="openpyxl")
                return df_final, sheetname, i

    raise ValueError(f"Aucune feuille ne contient les colonnes {colonnes_attendues}")

# Fusion F1 + F2
def fusion_excel(df1, df2, df3):
    # Normalisation colonnes
    df1.columns = [normaliser_texte(c) for c in df1.columns]
    df2.columns = [normaliser_texte(c) for c in df2.columns]
    df3.columns = [normaliser_texte(c) for c in df3.columns]

    # Renommage pour √©viter les confusions
    df1 = df1.rename(columns={"c": "nom", "pr√©nom": "prenom"})
    df2 = df2.rename(columns={"nom": "nom", "pr√©nom": "prenom", "ddn": "ddn", "nip": "ipp"})
    df3 = df3.rename(columns={"nom": "nom", "pr√©nom": "prenom", "ddn": "ddn", "nip": "ipp"})

    # Normaliser nom + pr√©nom
    for col in ["nom", "prenom"]:
        if col in df1:
            df1[col] = df1[col].astype(str).str.strip().str.upper()
        if col in df2:
            df2[col] = df2[col].astype(str).str.strip().str.upper()
        if col in df3:
            df3[col] = df3[col].astype(str).str.strip().str.upper()

    ref = pd.concat([df2, df3], ignore_index=True)
    ref = ref.drop_duplicates(subset=["nom", "prenom", "ipp"])

    df_merge = df1.merge(ref, on=["nom", "prenom"], how="inner")

    df_merge["ddn"] = pd.to_datetime(df_merge["ddn"], errors='coerce', dayfirst=True)
    df_merge["ddn"] = df_merge["ddn"].dt.strftime("%d/%m/%Y")

    df_merge = df_merge.sort_values(by="nom").reset_index(drop=True)

    return df_merge[["nom", "prenom", "ddn", "ipp"]]

# G√©n√©ration du fichier Excel t√©l√©chargeable
def generer_excel(df):
    output = BytesIO()
    with pd.ExcelWriter(output, engine="openpyxl") as writer:
        df.to_excel(writer, index=False, sheet_name="Croisement")
    return output.getvalue()

# -------------------------
# INTERFACE STREAMLIT
# -------------------------

def main():
    st.title("Croisement Fichiers Excel BHRe")
    st.write("### üóÇÔ∏è Importez les deux fichiers Excel")

    fichier1 = st.file_uploader("Fichier Indicateur", type=["xlsx"], key="file1")
    fichier2 = st.file_uploader("Fichier Suivi Termin√©", type=["xlsx"], key="file2")
    fichier3 = st.file_uploader("Fichier Suivi", type=["xlsx"], key="file3")

    if fichier1 and fichier2 and fichier3:
        try:
            st.info("üîç Analyse des fichiers...")

            # --- D√©tection bonne feuille / header ---
            df1, feuil1, ligne1 = trouver_feuille_avec_colonnes(
                fichier1, ["c", "pr√©nom"]
            )
            st.success(f"Fichier 1 ‚Üí feuille d√©tect√©e : **{feuil1}** (header ligne {ligne1})")
            st.dataframe(df1.head())

            df2, feuil2, ligne2 = trouver_feuille_avec_colonnes(
                fichier2, ["nom", "pr√©nom", "ddn", "nip"]
            )
            st.success(f"Fichier 2 ‚Üí feuille d√©tect√©e : **{feuil2}** (header ligne {ligne2})")
            st.dataframe(df2.head())

            df3, feuil3, ligne3 = trouver_feuille_avec_colonnes(
                fichier3, ["nom", "pr√©nom", "ddn", "ipp"]
            )
            st.success(f"Fichier 3 ‚Üí feuille d√©tect√©e : **{feuil3}** (header ligne {ligne3})")
            st.dataframe(df3.head())

            # --- Fusion ---
            st.info("üîó Fusion des fichiers...")
            df_result = fusion_excel(df1, df2, df3)

            st.success("Fusion termin√©e ! Aper√ßu :")
            st.dataframe(df_result.head())

            # --- Export Excel ---
            excel_data = generer_excel(df_result)

            st.download_button(
                label="üíæ T√©l√©charger le fichier fusionn√©",
                data=excel_data,
                file_name="Croisement_BHRe.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )

        except Exception as e:
            safe_show_exception(e)

InvalidIndexError: Reindexing only valid with uniquely valued Index objects
Traceback:
File "C:\Users\4251352\Portail_outils\outils\croisement_BHRe.py", line 119, in main
    df_result = fusion_excel(df1, df2, df3)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
File "C:\Users\4251352\Portail_outils\outils\croisement_BHRe.py", line 63, in fusion_excel
    ref = pd.concat([df2, df3], ignore_index=True)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
File "C:\Users\4251352\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\reshape\concat.py", line 395, in concat
    return op.get_result()
           ^^^^^^^^^^^^^^^
File "C:\Users\4251352\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\reshape\concat.py", line 680, in get_result
    indexers[ax] = obj_labels.get_indexer(new_labels)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
File "C:\Users\4251352\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\indexes\base.py", line 3892, in get_indexer
    raise InvalidIndexError(self._requires_unique_msg)
