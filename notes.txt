def normalize_um(value, width=4) -> str:
    """
    Normalise un code UM APHP :
    - cast en str
    - suppression espaces
    - suppression virgules
    - padding Ã  gauche sur 4 caractÃ¨res
    """
    if value is None:
        return ""
    s = str(value).strip()
    s = s.replace(" ", "")
    s = s.replace(",", "")
    if s == "" or s.lower() == "nan":
        return ""
    return s.zfill(width)


def read_um_mapping_xlsx_only(excel_bytes: bytes, excel_filename: str) -> pd.DataFrame:
    ext = (excel_filename or "").lower().split(".")[-1]
    if ext == "xls":
        raise ValueError(
            "Fichier Excel au format .xls dÃ©tectÃ©.\n"
            "Merci de l'enregistrer en .xlsx (Fichier > Enregistrer sous > .xlsx), "
            "puis de relancer l'outil."
        )

    bio = io.BytesIO(excel_bytes)
    df = pd.read_excel(bio, engine="openpyxl", skiprows=2)
    df = df.dropna(how="all")

    cols = {c: str(c).strip() for c in df.columns}
    df = df.rename(columns=cols)

    col_upper = {c.upper().replace(" ", "").replace("-", "_"): c for c in df.columns}
    urm_aphp_col = col_upper.get("URM_APHP") or col_upper.get("URMAPHP")
    urm_site_col = col_upper.get("URM_SITE") or col_upper.get("URMSITE")

    if not urm_aphp_col or not urm_site_col:
        raise ValueError(
            "Colonnes attendues non trouvÃ©es dans l'Excel. "
            "Il faut des colonnes 'URM_APHP' et 'URM_SITE'."
        )

    out = df[[urm_aphp_col, urm_site_col]].copy()
    out.columns = ["URM_APHP", "URM_SITE"]

    # ðŸ”¥ Normalisation propre
    out["URM_APHP"] = out["URM_APHP"].apply(lambda x: normalize_um(x, 4))
    out["URM_SITE"] = out["URM_SITE"].astype(str).str.strip()

    out = out[(out["URM_APHP"] != "")]
    out = out.drop_duplicates(subset=["URM_APHP"], keep="first")





def process_rss_text_mco(rss_bytes: bytes, mapping: dict, start_1_based: int, length: int):
    text = safe_decode_singlebyte(rss_bytes)
    lines = text.splitlines(True)

    start0 = start_1_based - 1
    end0 = start0 + length

    total = 0
    matched = 0
    missing_keys = Counter()

    out_lines = []

    for line in lines:
        if len(line) < end0:
            out_lines.append(line)
            continue

        seg = line[start0:end0]
        key = normalize_um(seg, length)

        total += 1

        if key in mapping:
            rep = mapping[key]
            rep_fixed = (rep + (" " * length))[:length]
            new_line = line[:start0] + rep_fixed + line[end0:]
            out_lines.append(new_line)
            matched += 1
        else:
            out_lines.append(line)
            missing_keys[key] += 1

    corrected = "".join(out_lines)

    stats = {
        "total_records_checked": total,
        "matched": matched,
        "match_rate": (matched / total) if total else 0.0,
        "missing_top10": missing_keys.most_common(10),
        "missing_unique": len(missing_keys),
    }

    return safe_encode_singlebyte(corrected), stats


def main():
    st.title("Formatage PMSIPilot â€” MCO (V1)")

    st.markdown(
        "- DÃ©pose un ZIP MCO (`mco_XXX_YYYYMM_in.zip`) + un Excel de correspondance UM.\n"
        "- âš ï¸ Seul le format .xlsx est acceptÃ©.\n"
        "- Le ZIP final contient les fichiers d'origine + rss.ini-corrige + vidhosp + rapport."
    )

    mode = st.selectbox("Type", ["Auto", "MCO", "SMR", "PSY"], index=0)

    col1, col2 = st.columns(2)
    with col1:
        uploaded_zip = st.file_uploader("ZIP d'entrÃ©e", type=["zip"])
    with col2:
        uploaded_excel = st.file_uploader("Excel correspondance UM (.xlsx requis)", type=["xls", "xlsx"])

    keep_original_rss = st.checkbox("Conserver le RSS original", value=True)
    min_match_rate = st.slider("Seuil minimum de match UM", 0.0, 1.0, 0.98, 0.01)

    if uploaded_zip and uploaded_excel:

        if uploaded_excel.name.lower().endswith(".xls"):
            st.error(
                "Fichier Excel au format .xls dÃ©tectÃ©.\n\n"
                "Merci de l'ouvrir et de l'enregistrer au format .xlsx."
            )
            return

        zip_bytes = uploaded_zip.read()
        excel_bytes = uploaded_excel.read()

        try:
            with zipfile.ZipFile(io.BytesIO(zip_bytes), "r") as z:
                namelist = z.namelist()
        except Exception as e:
            st.error(f"ZIP invalide: {e}")
            return

        detected = detect_domain(uploaded_zip.name, namelist)
        chosen = detected if mode == "Auto" else mode

        if chosen != "MCO":
            st.warning("Pour le moment seul le MCO est implÃ©mentÃ©.")
            return

        if st.button("Lancer le traitement", type="primary"):
            try:
                out_zip_bytes, report = process_zip_mco(
                    zip_bytes=zip_bytes,
                    zip_filename=uploaded_zip.name,
                    excel_bytes=excel_bytes,
                    excel_filename=uploaded_excel.name,
                    keep_original_rss=keep_original_rss,
                    rss_um_start_1based=87,
                    rss_um_length=4,
                    min_match_rate=float(min_match_rate),
                )
            except Exception as e:
                st.error(str(e))
                return

            st.success("Traitement terminÃ©.")
            st.text_area("Rapport", report, height=300)

            out_name = uploaded_zip.name.replace("_in.zip", "_out.zip")
            st.download_button(
                label="TÃ©lÃ©charger le ZIP formatÃ©",
                data=out_zip_bytes,
                file_name=out_name,
                mime="application/zip",
            )

    else:
        st.info("TÃ©lÃ©verse un ZIP + un Excel pour dÃ©marrer.")

    return out
