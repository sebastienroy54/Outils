import streamlit as st
import pandas as pd
import subprocess
import os
from io import BytesIO
from datetime import datetime

# =============================
# CONFIGURATION
# =============================
SQL_PATH = "Portail_outils/SQL/contigus.sql"
CSV_PATH = "Portail_outils/data/resultat.csv"
OUTPUT_PATH = "Portail_outils/data/doublons.xlsx"

st.set_page_config(page_title="Analyse des SÃ©jours Contigus & Doublons", layout="centered")

st.title("ðŸ” DÃ©tection des Doublons, Contigus et Chevauchements")
st.markdown("Cet outil exÃ©cute la requÃªte SQL, analyse les sÃ©jours et gÃ©nÃ¨re un fichier Excel structurÃ©.")

# =============================
# FORMULAIRE DE CONNEXION
# =============================
with st.form("connexion"):
    st.subheader("Connexion Oracle")
    user = st.text_input("ðŸ‘¤ Nom d'utilisateur Oracle :", value="", placeholder="ex: SIP_USER")
    password = st.text_input("ðŸ”‘ Mot de passe :", type="password")
    execute_sql = st.checkbox("ExÃ©cuter la requÃªte SQL avant analyse", value=False)
    submitted = st.form_submit_button("ðŸš€ Lancer le traitement")

if submitted:
    if not user or not password:
        st.error("Veuillez renseigner vos identifiants Oracle.")
        st.stop()

    # =============================
    # EXÃ‰CUTION DE LA REQUÃŠTE SQL
    # =============================
    if execute_sql:
        with st.spinner("ðŸ§  ExÃ©cution de la requÃªte SQL, veuillez patienter..."):
            tns_alias = "SIP1CCH.WORLD"
            cmd = f'sqlplus {user}/{password}@{tns_alias} @{SQL_PATH}'
            subprocess.run(cmd, shell=True)
        st.success("âœ… RequÃªte SQL terminÃ©e et fichier CSV gÃ©nÃ©rÃ©.")
        st.divider()

    if not os.path.exists(CSV_PATH):
        st.error(f"âŒ Le fichier {CSV_PATH} n'existe pas. Veuillez exÃ©cuter la requÃªte SQL.")
        st.stop()

    # =============================
    # ANALYSE PYTHON
    # =============================
    with st.spinner("ðŸ”Ž Analyse des sÃ©jours en cours..."):
        df = pd.read_csv(CSV_PATH, sep=';', skip_blank_lines=True, dtype=str)
        df = df.dropna(how='all')
        df.columns = [col.strip().upper() for col in df.columns]

        expected_cols = ["IPP", "DATE_NAISSANCE", "NDA", "UMA", "DATE_ENTREE", "DATE_SORTIE"]
        if df.shape[1] >= len(expected_cols):
            df.columns = expected_cols + [f"COL_EXTRA_{i}" for i in range(df.shape[1] - len(expected_cols))]

        df['IPP'] = df['IPP'].astype(str).str.strip()
        df['UMA'] = df['UMA'].astype(str).str.strip()
        df['NDA'] = df['NDA'].astype(str).str.strip()
        df['DATE_ENTREE'] = pd.to_datetime(df['DATE_ENTREE'], dayfirst=True, errors='coerce')
        df['DATE_SORTIE'] = pd.to_datetime(df['DATE_SORTIE'], dayfirst=True, errors='coerce')

        df = df.dropna(subset=["DATE_ENTREE", "DATE_SORTIE", "UMA", "IPP"])
        df = df.sort_values(['IPP', 'DATE_ENTREE', 'DATE_SORTIE']).reset_index(drop=True)

        rows = []
        for ipp, group in df.groupby('IPP', sort=False):
            g = group.reset_index(drop=True)
            n = len(g)
            for i in range(n):
                nda1, uma1, de1, ds1 = g.loc[i, ['NDA', 'UMA', 'DATE_ENTREE', 'DATE_SORTIE']]
                j = i + 1
                while j < n:
                    de2 = g.loc[j, 'DATE_ENTREE']
                    if pd.isna(de2):
                        j += 1
                        continue
                    if de2 > ds1 and de2 != ds1:
                        break
                    nda2, uma2, ds2 = g.loc[j, ['NDA', 'UMA', 'DATE_SORTIE']]
                    if nda1 == nda2:
                        j += 1
                        continue

                    rel = None
                    if (uma1 == uma2) and (de1 == de2) and (ds1 == ds2):
                        rel = "VRAI_DOUBLON"
                    elif (uma1 != uma2) and (de1 == de2) and (ds1 == ds2):
                        rel = "DOUBLON_0_NUIT"
                    elif (uma1 != uma2) and ((ds1 == de2) or (ds2 == de1)):
                        rel = "CONTIGUS"
                    elif (uma1 != uma2) and (de1 < ds2) and (ds1 > de2):
                        rel = "CHEVAUCHEMENT"

                    if rel:
                        rows.append({
                            "IPP": ipp,
                            "DATE_NAISSANCE": g.loc[i, 'DATE_NAISSANCE'],
                            "NDA1": nda1,
                            "UMA1": uma1,
                            "DATEE1": de1,
                            "DATES1": ds1,
                            "NDA2": nda2,
                            "UMA2": uma2,
                            "DATEE2": de2,
                            "DATES2": ds2,
                            "TYPE_RELATION": rel
                        })
                    j += 1

        res = pd.DataFrame(rows).drop_duplicates()
        cols = ["IPP", "DATE_NAISSANCE", "NDA1", "UMA1", "DATEE1", "DATES1", "NDA2", "UMA2", "DATEE2", "DATES2"]

        # Sauvegarde Excel
        with pd.ExcelWriter(OUTPUT
