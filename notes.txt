AttributeError: 'MergedCell' object has no attribute 'column_letter'
Traceback:
File "C:\Users\4251352\Portail_outils\app.py", line 16, in <module>
    tableau_comparaison_valo.main()
File "C:\Users\4251352\Portail_outils\outils\tableau_comparaison_valo.py", line 165, in main
File "C:\Users\4251352\Portail_outils\outils\tableau_comparaison_valo.py", line 109, in generer_excel

import streamlit as st
import pandas as pd
from io import BytesIO
from openpyxl.styles import Font, Alignment, PatternFill
from openpyxl.utils import get_column_letter

# -----------------------
# Helpers
# -----------------------
def safe_show_exception(e):
    """Affiche un message utilisateur simple et propose d'afficher le d√©tail technique."""
    st.error("Une erreur est survenue pendant le traitement. Veuillez v√©rifier vos fichiers ou contacter le support.")
    if st.checkbox("Afficher les d√©tails techniques (pour un d√©veloppeur)"):
        st.exception(e)

def lire_fichier_excel(fichier, widget_label="fichier"):
    """Lit un fichier Excel et renvoie (annee, data, meta)."""
    try:
        df = pd.read_excel(fichier, header=None)
    except Exception as e:
        raise RuntimeError(f"Impossible de lire le {widget_label} : le fichier n'est pas un Excel lisible.") from e

    try:
        # m√©tadonn√©es
        resume_filtrage = df.iloc[3, 0]
        periode = str(df.iloc[4, 0])
        filtres = df.iloc[5, 0]
        detail_valo = df.iloc[7, 0]

        # extraire ann√©e depuis la ligne de p√©riode
        import re
        match = re.search(r"(\d{4})", periode)
        annee = match.group(1) if match else "XXXX"

        # lire le tableau √† partir de la ligne 9 (index 8)
        data = pd.read_excel(fichier, header=8)
        data = data.iloc[:, :4]
        data.columns = ["Indicateur", "Valorisation", "Quantit√©", "Unit√©"]
    except Exception as e:
        raise RuntimeError("Le format du fichier Excel ne correspond pas au mod√®le attendu (v√©rifier les lignes d'en-t√™te et la structure).") from e

    return annee, data, {
        "R√©sum√© de filtrage": resume_filtrage,
        "P√©riode": periode,
        "Filtres": filtres,
        "D√©tail valorisation": detail_valo
    }

def creer_tableau_comparatif(df_new, annee_new, df_old, annee_old):
    """Fusionne en gardant l'ordre df_new (le plus r√©cent)."""
    try:
        df_new = df_new.rename(columns={
            "Valorisation": f"Valorisation {annee_new}",
            "Quantit√©": f"Quantit√© {annee_new}",
            "Unit√©": f"Unit√© {annee_new}"
        })
        df_old = df_old.rename(columns={
            "Valorisation": f"Valorisation {annee_old}",
            "Quantit√©": f"Quantit√© {annee_old}",
            "Unit√©": f"Unit√© {annee_old}"
        })

        # merge en gardant l'ordre de df_new
        df_merge = df_new.merge(df_old, on="Indicateur", how="left", sort=False)

        # Calcul de l‚Äô√©cart
        df_merge[f"√âcart Valorisation ({annee_new}-{annee_old})"] = (
            df_merge.get(f"Valorisation {annee_new}") - df_merge.get(f"Valorisation {annee_old}")
        )
    except Exception as e:
        raise RuntimeError("Erreur lors de la cr√©ation du tableau comparatif.") from e

    return df_merge

def format_valeur_monetaire_cell(val):
    """Retourne cha√Æne format√©e: 1 234 567 ‚Ç¨ ou vide si NaN."""
    try:
        if pd.isna(val) or val == "":
            return ""
        v = float(val)
        s = f"{v:,.0f}".replace(",", " ")
        return f"{s} ‚Ç¨"
    except:
        return val

def generer_excel(df, annee_new, annee_old):
    """G√©n√®re un fichier Excel stylis√© et renvoie BytesIO."""
    try:
        output = BytesIO()
        titre = f"Comparatif {annee_new} vs {annee_old}"

        for col in df.columns:
            if "Quantit√©" in col:
                df[col] = df[col].apply(lambda x: int(x) if pd.notna(x) else x)

        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            # √©crire le df √† partir de la ligne 2 (ligne 1 = titre)
            df.to_excel(writer, index=False, sheet_name="Comparatif", startrow=1)
            wb = writer.book
            ws = wb["Comparatif"]

            # titre : appliquer le style avant de merger
            cell_titre = ws.cell(row=1, column=1)
            cell_titre.value = titre
            cell_titre.font = Font(size=14, bold=True)
            cell_titre.alignment = Alignment(horizontal="center")
            last_col_idx = df.shape[1]
            ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=last_col_idx)

            # style header (ligne 2)
            header_fill = PatternFill(start_color="D9D9D9", end_color="D9D9D9", fill_type="solid")
            for c_idx in range(1, last_col_idx + 1):
                try:
                    cell = ws.cell(row=2, column=c_idx)
                    cell.font = Font(bold=True)
                    cell.alignment = Alignment(horizontal="center")
                    cell.fill = header_fill
                except AttributeError:
                    continue
                
            # identifier colonnes de valorisation et d'√©cart
            valorisation_cols_idx = [i+1 for i, c in enumerate(df.columns) if "Valorisation" in c]
            ecart_col_idx = None
            for i, c in enumerate(df.columns, start=1):
                if "√âcart Valorisation" in c:
                    ecart_col_idx = i
                    break
            if ecart_col_idx and ecart_col_idx not in valorisation_cols_idx:
                valorisation_cols_idx.append(ecart_col_idx)

            # formater les cellules de valorisation
            for row in range(3, len(df) + 3):
                for col_idx in valorisation_cols_idx:
                    cell = ws.cell(row=row, column=col_idx)
                    raw_val = cell.value
                    if raw_val is None or raw_val == "":
                        cell.value = ""
                        continue
                    try:
                        val_float = float(raw_val)
                        cell.value = format_valeur_monetaire_cell(val_float)
                        if val_float < 0:
                            cell.font = Font(color="FF0000")
                    except Exception:
                        pass

            # ajustement largeur colonnes
            for idx in range(1, last_col_idx + 1):
                col_letter = get_column_letter(idx)
                max_length = 0
                for r in range(1, len(df) + 3):
                    try:
                        cell = ws.cell(row=r, column=idx)
                        if cell.value is not None:
                            max_length = max(max_length, len(str(cell.value)))
                    except AttributeError:
                        continue
                ws.column_dimensions[col_letter].width = max(8, max_length + 2)

        output.seek(0)
        return output

    except Exception as e:
        raise RuntimeError("Impossible de g√©n√©rer le fichier Excel (v√©rifiez les donn√©es).") from e

def afficher_tableau_colore(df, annee_new, annee_old):
    """Affiche le tableau dans Streamlit (format mon√©taire et texte rouge pour n√©gatifs)."""
    try:
        valorisation_cols = [c for c in df.columns if "Valorisation" in c or "√âcart Valorisation" in c]
        df_styled = df.copy()
        for col in valorisation_cols:
            def fmt(v):
                try:
                    if pd.isna(v) or v == "":
                        return ""
                    return format_valeur_monetaire_cell(float(v))
                except:
                    return v
            df_styled[col] = df_styled[col].apply(fmt)

        def color_neg(v):
            try:
                if isinstance(v, str):
                    s = v.replace("‚Ç¨", "").replace(" ", "").replace(",", ".").strip()
                    val = float(s) if s != "" else 0.0
                else:
                    val = float(v)
                return 'color: red' if val < 0 else ''
            except:
                return ''

        st.markdown(f"### üìä Comparatif {annee_new} vs {annee_old}")
        st.dataframe(df_styled.style.applymap(color_neg, subset=valorisation_cols))

    except Exception as e:
        raise RuntimeError("Erreur lors de l'affichage du tableau.") from e

# -----------------------
# main()
# -----------------------
def main():
    st.title("üí∂ Comparateur de Valorisation T2A")
    st.write("### üóÇÔ∏è Importez les deux fichiers Excel (respecter le mod√®le de fichier)")

    fichier1 = st.file_uploader("Fichier r√©cent (ex: 2025)", type=["xlsx"], key="file1")
    fichier2 = st.file_uploader("Fichier ancien (ex: 2024)", type=["xlsx"], key="file2")

    if not (fichier1 and fichier2):
        st.info("Veuillez uploader les deux fichiers pour comparer.")
        return

    if not st.button("Lancer la comparaison"):
        return

    try:
        annee1, df1, meta1 = lire_fichier_excel(fichier1, widget_label="premier fichier")
        annee2, df2, meta2 = lire_fichier_excel(fichier2, widget_label="deuxi√®me fichier")

        try:
            if int(annee1) < int(annee2):
                st.info(f"Inversion d√©tect√©e : {annee1} < {annee2}. Les fichiers seront r√©ordonn√©s automatiquement.")
                annee1, annee2 = annee2, annee1
                df1, df2 = df2, df1
        except Exception:
            st.warning("Impossible de d√©terminer l'ordre des ann√©es automatiquement (format de la p√©riode inattendu).")

        st.write("### üßæ M√©tadonn√©es")
        st.write(f"**P√©riode {annee1} :** {meta1.get('P√©riode','')}")
        st.write(f"**P√©riode {annee2} :** {meta2.get('P√©riode','')}")

        df_comparatif = creer_tableau_comparatif(df1, annee1, df2, annee2)
        afficher_tableau_colore(df_comparatif, annee1, annee2)

        excel_data = generer_excel(df_comparatif, annee1, annee2)
        st.download_button(
            label="üíæ T√©l√©charger le comparatif (Excel)",
            data=excel_data,
            file_name=f"Comparatif_{annee1}_{annee2}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )

    except Exception as e:
        safe_show_exception(e)

if __name__ == "__main__":
    main()
