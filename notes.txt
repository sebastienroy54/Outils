# RUM_TIM.py
import streamlit as st
import pandas as pd
import subprocess
import time
from pathlib import Path
from datetime import datetime
from io import BytesIO
from openpyxl import load_workbook

# --------------------------
# CONFIG ‚Äî adapte si besoin
# --------------------------
BASE_DIR = Path("C:/Users/4251352/Portail_outils")
DATA_DIR = BASE_DIR / "data"
SQL_DIR = BASE_DIR / "SQL"

PATRON_XLSX = DATA_DIR / "tableau_rum_tim.xlsx"

TNS_MAP = {
    "CCH": "SIP1CCH.WORLD",
    "BRC": "SIP1BRC.WORLD",
    "HTD": "SIP_HTD.WORLD"
}

# --------------------------
# OUTILS / UTILITAIRES
# --------------------------
def safe_show_exception(e):
    st.error("Une erreur est survenue. V√©rifiez vos fichiers ou contactez le support.")
    if st.checkbox("Afficher d√©tails techniques"):
        st.exception(e)

def run_sqlplus_and_wait(cmd, timeout=30):
    proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    start = time.time()
    output = ""
    while True:
        if proc.poll() is not None:
            out, _ = proc.communicate()
            output += (out or "")
            break
        if time.time() - start > timeout:
            proc.kill()
            raise TimeoutError("Timeout lors de l'ex√©cution de sqlplus.")
        time.sleep(0.1)
    return output

def test_connection_with_sqlplus(user, password, tns_alias, timeout=3):
    test_sql = SQL_DIR / "test_connexion.sql"
    test_sql.write_text("set heading off\nset feedback off\nselect 1 from dual;\nexit;\n", encoding="utf-8")
    cmd = f'sqlplus -S {user}/{password}@{tns_alias} @{test_sql}'
    try:
        out = run_sqlplus_and_wait(cmd, timeout=timeout)
    except Exception as e:
        raise
    finally:
        try:
            test_sql.unlink()
        except Exception:
            pass
    return "1" in out

def build_sql_spool_rum(site_label, file_spool_path, mode, month, year):
    if mode == "mois":
        start = f"01/{int(month):02d}/{year}"
        end_expr = f"LAST_DAY(TO_DATE('01/{int(month):02d}/{year}','DD/MM/YYYY'))"
        where_clause = (f"D8EEUE BETWEEN TO_DATE('{start}','DD/MM/YYYY') "
                        f"AND {end_expr}")
    else:
        start = f"01/01/{year}"
        end_expr = f"LAST_DAY(TO_DATE('01/{int(month):02d}/{year}','DD/MM/YYYY'))"
        where_clause = (f"D8EEUE BETWEEN TO_DATE('{start}','DD/MM/YYYY') "
                        f"AND {end_expr}")

    sql = f"""
SET HEADING OFF
SET FEEDBACK OFF
SET PAGESIZE 0
SET LINESIZE 2000
SET TRIMSPOOL ON
spool {file_spool_path}
SELECT CDURM_P || ';' || COUNT(*)
FROM RSM
WHERE {where_clause}
GROUP BY CDURM_P;
spool off
exit;
"""
    return sql

def read_spool_csv_to_df(spool_path):
    p = Path(spool_path)
    if not p.exists():
        return pd.DataFrame(columns=["UMA", "COUNT"])
    try:
        df = pd.read_csv(p, sep=';', header=None, dtype=str, names=["UMA", "COUNT"], engine="python")
        df["UMA"] = df["UMA"].astype(str).str.strip()
        df["COUNT"] = pd.to_numeric(df["COUNT"].astype(str).str.strip().replace("", "0"), errors="coerce").fillna(0).astype(int)
        return df
    except Exception:
        lines = p.read_text(encoding="utf-8", errors="ignore").splitlines()
        rows = []
        for line in lines:
            if ";" in line:
                a, b = line.split(";", 1)
                rows.append({"UMA": a.strip(), "COUNT": int(b.strip() or 0)})
        return pd.DataFrame(rows)

# --------------------------
# EXCEL HELPERS (logique DMU + √©criture dans workbook en m√©moire)
# --------------------------
def extract_uma_key(uma_cell_text):
    """
    Extrait le code UMA tel que demand√© : tout jusqu'au premier espace.
    Si pas d'espace, retourne la cha√Æne compl√®te (trim√©e).
    """
    if uma_cell_text is None:
        return ""
    s = str(uma_cell_text).strip()
    if s == "":
        return ""
    parts = s.split(" ", 1)
    return parts[0].strip()

def compute_dmu_totals_in_df(df):
    """
    Pour chaque ligne dont UMA commence par 'Total DMU', on somme les lignes AU-DESSUS
    (dans le dataframe ordonn√©) jusqu'√† rencontrer une autre ligne 'Total DMU' ou le d√©but.
    Modifie df in-place et retourne df.
    """
    # Assurer colonnes num√©riques
    df["RUM du mois"] = pd.to_numeric(df["RUM du mois"].fillna(0), errors="coerce").fillna(0).astype(int)
    df["RUM cumul√©s"] = pd.to_numeric(df["RUM cumul√©s"].fillna(0), errors="coerce").fillna(0).astype(int)

    # Trouver tous les indices o√π UMA commence par "Total DMU"
    total_indices = [i for i, v in df["UMA"].fillna("").astype(str).str.strip().items() if str(v).strip().startswith("Total DMU")]
    # Note: .items() returns (index, value) so adjust:
    total_indices = [idx for idx, val in df["UMA"].fillna("").astype(str).str.strip().items() if val.startswith("Total DMU")]

    # If none, return
    if not total_indices:
        return df

    # For each total index, sum rows above until previous total index (exclusive) or start
    # We'll process in order of appearance
    for t_idx in total_indices:
        # sum from (prev_total_idx + 1) to (t_idx - 1) inclusive
        # Find previous total index that is < t_idx
        prev_totals = [x for x in total_indices if x < t_idx]
        if prev_totals:
            start_idx = max(prev_totals) + 1
        else:
            start_idx = 0  # header row corresponds to df index 0
        # Sum rows from start_idx to t_idx-1
        if t_idx - 1 >= start_idx:
            block = df.loc[start_idx:t_idx - 1]
            sum_mois = int(block["RUM du mois"].astype(int).sum())
            sum_cum = int(block["RUM cumul√©s"].astype(int).sum())
        else:
            sum_mois = 0
            sum_cum = 0
        df.at[t_idx, "RUM du mois"] = sum_mois
        df.at[t_idx, "RUM cumul√©s"] = sum_cum

    return df

def write_values_back_to_workbook(df, wb):
    """
    √âcrit les colonnes 'RUM du mois' et 'RUM cumul√©s' du dataframe df dans le workbook wb
    en trouvant automatiquement la ligne d'en-t√™te (Site & UMA) et les colonnes correspondantes.
    On n'alt√®re pas les styles existants, on ne change pas les largeurs.
    """
    ws = wb.active

    # trouver la ligne d'ent√™te (on cherche 'Site' et 'UMA' sur la m√™me ligne)
    header_row = None
    max_scan = min(ws.max_row, 40)
    for r in range(1, max_scan + 1):
        row_vals = [str(ws.cell(row=r, column=c).value).strip().lower() if ws.cell(row=r, column=c).value is not None else "" for c in range(1, min(ws.max_column, 40) + 1)]
        if "site" in row_vals and "uma" in row_vals:
            header_row = r
            break
    if header_row is None:
        # fallback to 1
        header_row = 1

    # map headers to column indices (case-insensitive)
    header_map = {}
    for c in range(1, ws.max_column + 1):
        val = ws.cell(row=header_row, column=c).value
        if val is None:
            continue
        header_map[str(val).strip().lower()] = c

    required = ["site", "uma", "type", "rum du mois", "rum cumul√©s"]
    for req in required:
        if req not in header_map:
            raise ValueError(f"En-t√™te attendue introuvable dans le patron : '{req}' (inspect√© '{header_row}')")

    col_idx_mois = header_map["rum du mois"]
    col_idx_cum = header_map["rum cumul√©s"]

    # Write values row by row into workbook, preserving existing cell styles
    start_row = header_row + 1
    for i in range(len(df)):
        target_row = start_row + i
        val_mois = int(df.at[i, "RUM du mois"])
        val_cum = int(df.at[i, "RUM cumul√©s"])
        # write only values
        ws.cell(row=target_row, column=col_idx_mois, value=val_mois)
        ws.cell(row=target_row, column=col_idx_cum, value=val_cum)

# --------------------------
# PAGES STREAMLIT
# --------------------------
def page_connexion():
    st.title("Connexion Oracle")

    if "oracle_connected" not in st.session_state:
        st.session_state.oracle_connected = False

    if not st.session_state.oracle_connected:
        with st.form("connexion"):
            st.subheader("Connexion Oracle")
            user = st.text_input("üë§ Nom d'utilisateur Oracle :", value="", key="conn_user")
            password = st.text_input("üîë Mot de passe :", type="password", key="conn_pwd")
            submitted = st.form_submit_button("üöÄ Se connecter")

        if submitted:
            if not user or not password:
                st.error("Veuillez renseigner vos identifiants Oracle.")
                return

            try:
                st.info("Test de connexion...")
                tns_to_test = TNS_MAP.get("CCH")
                test_sql_path = SQL_DIR / "test_connexion.sql"
                test_sql_path.write_text("select 1 from dual;\nexit;", encoding="utf-8")
                test_cmd = f"sqlplus -S {user}/{password}@{tns_to_test} @{test_sql_path}"

                out = run_sqlplus_and_wait(test_cmd, timeout=3)
                try:
                    test_sql_path.unlink()
                except Exception:
                    pass

                if "1" in out:
                    st.session_state.oracle_user = user
                    st.session_state.oracle_password = password
                    st.session_state.oracle_connected = True
                    st.session_state.logged_in = True
                    st.session_state.page = "rum"
                    st.experimental_rerun()
                else:
                    st.error("Connexion √©chou√©e. V√©rifiez vos identifiants Oracle.")
            except Exception as e:
                safe_show_exception(e)
                return
    else:
        st.success("Vous √™tes d√©j√† connect√© (identifiants en session).")
        if st.button("Aller √† la page RUM"):
            st.session_state.page = "rum"
            st.experimental_rerun()

def page_rum():
    st.title("Remplissage RUM ‚Äî TIM")

    if "oracle_connected" not in st.session_state or not st.session_state.oracle_connected:
        st.error("Vous devez d'abord vous connecter sur la page Connexion.")
        return

    # S√©lecteurs mois/ann√©e
    mois = st.selectbox("Choisir le mois", list(range(1, 13)), index=datetime.now().month - 1)
    annees = list(range(2013, datetime.now().year + 1))
    annee = st.selectbox("Choisir l'ann√©e", annees, index=len(annees)-1)

    bouton = st.button("Lancer le traitement RUM")

    st.markdown("**Remarque :** le script va interroger les 3 TNS (CCH, BRC, HTD) et spooler 2 CSV par site (mois + cumul).")
    st.info(f"Fichiers lus/√©crits dans : `{DATA_DIR}`")

    if not bouton:
        return

    try:
        progress = st.progress(0)
        progress.progress(5)

        # Lecture du patron excel
        if not PATRON_XLSX.exists():
            st.error(f"Fichier patron introuvable : {PATRON_XLSX}")
            return

        # Lire le patron en pandas (pour le mapping logique)
        # Important: read all rows as strings to preserve UMA text exactly
        df_patron = pd.read_excel(PATRON_XLSX, engine="openpyxl", dtype=str)
        # Ensure expected columns exist (case-sensitive names as in patron)
        expected_cols = ["Site", "UMA", "Type", "RUM du mois", "RUM cumul√©s", "TIM r√©f√©rent", "Relance"]
        for c in expected_cols:
            if c not in df_patron.columns:
                st.error(f"Colonne attendue introuvable dans le patron : '{c}'")
                return

        # Normalisation / pr√©paration des colonnes RUM
        df_patron["RUM du mois"] = pd.to_numeric(df_patron["RUM du mois"].fillna(0), errors="coerce").fillna(0).astype(int)
        df_patron["RUM cumul√©s"] = pd.to_numeric(df_patron["RUM cumul√©s"].fillna(0), errors="coerce").fillna(0).astype(int)

        progress.progress(10)

        # Pour chaque site : cr√©er SQL temp, ex√©cuter via sqlplus, lire CSV
        results_mois = {}
        results_cumule = {}

        for i, site_label in enumerate(["CCH", "BRC", "HTD"], start=1):
            try:
                tns = TNS_MAP.get(site_label)
                spool_mois = DATA_DIR / f"RUM_MOIS_{site_label}.csv"
                spool_cumule = DATA_DIR / f"RUM_CUMULE_{site_label}.csv"

                sql_mois = build_sql_spool_rum(site_label, str(spool_mois), mode="mois", month=mois, year=annee)
                sql_cum = build_sql_spool_rum(site_label, str(spool_cumule), mode="cumule", month=mois, year=annee)

                tmp_sql_mois = SQL_DIR / f"rum_mois_{site_label}.sql"
                tmp_sql_cum = SQL_DIR / f"rum_cumule_{site_label}.sql"
                tmp_sql_mois.write_text(sql_mois, encoding="utf-8")
                tmp_sql_cum.write_text(sql_cum, encoding="utf-8")

                st.info(f"Ex√©cution SQL pour {site_label} (mois)...")
                cmd_mois = f"sqlplus -S {st.session_state.oracle_user}/{st.session_state.oracle_password}@{tns} @{tmp_sql_mois}"
                out_m = run_sqlplus_and_wait(cmd_mois, timeout=60)
                time.sleep(0.2)

                st.info(f"Ex√©cution SQL pour {site_label} (cumul√©)...")
                cmd_cum = f"sqlplus -S {st.session_state.oracle_user}/{st.session_state.oracle_password}@{tns} @{tmp_sql_cum}"
                out_c = run_sqlplus_and_wait(cmd_cum, timeout=60)
                time.sleep(0.2)

                # Lire les spools
                df_m = read_spool_csv_to_df(spool_mois)
                df_c = read_spool_csv_to_df(spool_cumule)

                # stocker en dict pour lookup rapide (cl√© = UMA code)
                results_mois[site_label] = {row["UMA"]: int(row["COUNT"]) for _, row in df_m.iterrows()}
                results_cumule[site_label] = {row["UMA"]: int(row["COUNT"]) for _, row in df_c.iterrows()}

                # cleanup temp sql files (on garde spools pour debug)
                try:
                    tmp_sql_mois.unlink()
                    tmp_sql_cum.unlink()
                except Exception:
                    pass

                progress.progress(int(10 + i * 25))
            except Exception as e_site:
                safe_show_exception(e_site)
                results_mois[site_label] = {}
                results_cumule[site_label] = {}
                continue

        # Maintenant on mappe les r√©sultats dans le df_patron (pandas)
        for idx, row in df_patron.iterrows():
            try:
                site = str(row.get("Site", "")).strip()
                uma_full = str(row.get("UMA", "")).strip()
                if uma_full == "" or site == "":
                    df_patron.at[idx, "RUM du mois"] = 0
                    df_patron.at[idx, "RUM cumul√©s"] = 0
                    continue

                uma_code = extract_uma_key(uma_full)  # tout avant le premier espace
                # R√©cup√©ration: on tente d'abord par site, si absent on essaie global (tous sites)
                val_mois = results_mois.get(site, {}).get(uma_code, None)
                val_cum = results_cumule.get(site, {}).get(uma_code, None)

                if val_mois is None:
                    # chercher dans tous les sites (fusion)
                    for s in results_mois:
                        if uma_code in results_mois[s]:
                            val_mois = results_mois[s][uma_code]
                            break
                if val_cum is None:
                    for s in results_cumule:
                        if uma_code in results_cumule[s]:
                            val_cum = results_cumule[s][uma_code]
                            break

                df_patron.at[idx, "RUM du mois"] = int(val_mois or 0)
                df_patron.at[idx, "RUM cumul√©s"] = int(val_cum or 0)
            except Exception as e_map:
                safe_show_exception(e_map)
                df_patron.at[idx, "RUM du mois"] = 0
                df_patron.at[idx, "RUM cumul√©s"] = 0

        progress.progress(95)

        # Calculer les totaux DMU automatiquement (mise √† jour dans df_patron)
        df_patron = compute_dmu_totals_in_df(df_patron)

        # Charger une copie du patron et √©crire les valeurs dans cette copie (en m√©moire)
        wb = load_workbook(PATRON_XLSX)
        write_values_back_to_workbook(df_patron, wb)

        # Sauvegarde en m√©moire uniquement et download
        output = BytesIO()
        wb.save(output)
        output.seek(0)
        file_name = f"tableau_rum_tim_rempli_{mois:02d}_{annee}.xlsx"

        progress.progress(100)
        st.success("Traitement termin√© ‚Äî fichier pr√™t au t√©l√©chargement üéâ")

        st.download_button(
            "üì• T√©l√©charger le fichier RUM compl√©t√©",
            data=output,
            file_name=file_name,
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )

    except Exception as e:
        safe_show_exception(e)

# --------------------------
# SESSION / MAIN
# --------------------------
def ensure_session_vars():
    defaults = {
        "logged_in": False,
        "oracle_connected": False,
        "page": "connexion",
        "oracle_user": "",
        "oracle_password": ""
    }
    for k, v in defaults.items():
        if k not in st.session_state:
            st.session_state[k] = v

def main():
    st.set_page_config(page_title="RUM TIM", layout="centered")
    ensure_session_vars()

    if "page" not in st.session_state:
        st.session_state.page = "connexion"

    try:
        if st.session_state.page == "connexion":
            page_connexion()
        else:
            page_rum()
    except Exception as e:
        safe_show_exception(e)

if __name__ == "__main__":
    main()
