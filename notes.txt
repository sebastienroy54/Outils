import numpy as np
import re

# --- 1) Nettoyage NDA : enlever un H en début (ex: H615487649 -> 615487649) ---
df_final["nda"] = (
    df_final["nda"]
    .astype(str)
    .str.strip()
    .str.replace(r"^H(?=61\d+)", "", regex=True)   # enlève H uniquement si ça suit par 61...
    .str.replace(r"\.0$", "", regex=True)
    .replace({"nan": "", "None": ""})
)

# --- 2) Nettoyage IPP (juste au cas où) ---
df_final["ipp"] = (
    df_final["ipp"]
    .astype(str)
    .str.strip()
    .str.replace(r"\.0$", "", regex=True)
    .replace({"nan": "", "None": ""})
)

# --- 3) Convertir date_pose en datetime (si pas déjà) ---
df_final["date_pose"] = pd.to_datetime(df_final["date_pose"], errors="coerce", dayfirst=True)

# --- 4) Split Nom/Prénom pour le dernier code (3416095) basé sur la "signature" des prénoms ---
# Hypothèse: dans 3416095, tu as mis "Nom Prénom" dans df_final["nom"] et prenom vide.
# On split en se basant sur le premier token "Prénom-like" (Title Case) après des tokens NOM souvent en majuscules.

def is_titlecase_word(w: str) -> bool:
    # Exemple: "Jean", "Marie", "Léo", "Anne-Sophie"
    if not w:
        return False
    # garde lettres + tirets/apostrophes
    w2 = re.sub(r"[^A-Za-zÀ-ÖØ-öø-ÿ'\-]", "", w)
    return bool(w2) and (w2[0].isupper()) and (w2[1:].islower() or w2[1:].replace("-", "").replace("'", "").islower())

def split_nom_prenom(full: str):
    if full is None:
        return "", ""
    s = str(full).strip()
    if not s:
        return "", ""

    parts = s.split()
    if len(parts) == 1:
        return s, ""

    # Trouve l’index où commence le prénom (premier mot TitleCase)
    idx = None
    for i, w in enumerate(parts):
        if is_titlecase_word(w):
            idx = i
            break

    if idx is None or idx == 0:
        # pas détectable proprement
        return s, ""

    nom = " ".join(parts[:idx]).strip()
    prenom = " ".join(parts[idx:]).strip()
    return nom, prenom

mask_3416095 = df_final["lppr"].astype(str).eq("3416095")
mask_need_split = mask_3416095 & df_final["prenom"].astype(str).str.strip().eq("") & df_final["nom"].astype(str).str.strip().ne("")

splits = df_final.loc[mask_need_split, "nom"].apply(split_nom_prenom)
df_final.loc[mask_need_split, "nom"] = splits.apply(lambda x: x[0])
df_final.loc[mask_need_split, "prenom"] = splits.apply(lambda x: x[1])

# --- 5) Filtrage des lignes inutilisables ---
# Règles:
# - si pas de date_pose ET pas de NDA => on enlève
# - si pas d'IPP ET pas de NDA => on enlève
no_date_and_no_nda = df_final["date_pose"].isna() & df_final["nda"].eq("")
no_id = df_final["ipp"].eq("") & df_final["nda"].eq("")

df_final = df_final.loc[~(no_date_and_no_nda | no_id)].copy()

# Optionnel: reset index
df_final.reset_index(drop=True, inplace=True)
