# ----------------- Fonctions modifiées / ajoutées -----------------

def build_tim_uma_dict(patron_path):
    """
    Idem qu'avant mais nettoyage TIM renforcé pour éviter doublons dus à
    caractères invisibles (ZERO WIDTH, BOM, nbsp, etc.).
    Retourne : { TIM: { SITE: { DMU: [UMA,...] } } }
    """
    df = pd.read_excel(patron_path, engine="openpyxl", dtype=str)
    df.columns = [c.strip() for c in df.columns]

    for col in ["Site", "UMA", "DMU"]:
        if col not in df.columns:
            raise KeyError(f"Colonne manquante : {col}")

    tim_ref_col = "TIM Référent" if "TIM Référent" in df.columns else None
    relance_col = "Relance" if "Relance" in df.columns else None

    def clean_tim(tim):
        if not isinstance(tim, str):
            return ""
        # supprimer caractères invisibles courants et normaliser espaces
        s = tim.replace("\u200b", "") \
               .replace("\ufeff", "") \
               .replace("\u00a0", " ") \
               .replace("\u200e", "") \
               .replace("\u200f", "")
        s = re.sub(r'\s+', ' ', s).strip()
        return s

    result = {}
    for _, row in df.iterrows():
        raw_uma = row.get("UMA", "")
        if not isinstance(raw_uma, str) or raw_uma.strip() == "" or raw_uma.startswith("Total DMU"):
            continue
        uma_code = extract_uma_code_by_space(raw_uma)
        site = str(row.get("Site", "")).strip() or "UNKNOWN"
        raw_dmu = row.get("DMU", "")
        dmu_code = normalize_dmu(raw_dmu)
        if dmu_code == "":
            continue

        tims = []
        if tim_ref_col:
            tims += split_tims(row.get(tim_ref_col, ""))
        if relance_col:
            tims += split_tims(row.get(relance_col, ""))

        if not tims:
            continue

        for tim in tims:
            tim_norm = clean_tim(tim)
            if not tim_norm:
                continue
            result.setdefault(tim_norm, {}).setdefault(site, {}).setdefault(dmu_code, set()).add(uma_code)

    # convertir sets en listes triées
    result_listified = {
        tim: {
            site: {dmu: sorted(list(umas)) for dmu, umas in dmus.items()}
            for site, dmus in sites.items()
        }
        for tim, sites in result.items()
    }
    return result_listified


def merge_vertical_conditionnel(ws, col_idx, df_col, start_row, group_col=None):
    """
    Fusionne verticalement les cellules de la colonne `col_idx` dans la feuille `ws`
    pour les lignes consécutives où df_col a la même valeur et, si group_col fourni,
    où group_col est identique (typical: TIM).
    - start_row : ligne excel correspondant à df_col.index[0]
    """
    if len(df_col) == 0:
        return
    current_val = df_col.iloc[0]
    current_group = group_col.iloc[0] if group_col is not None else None
    start_idx = 0

    for i in range(1, len(df_col)):
        val = df_col.iloc[i]
        group_val = group_col.iloc[i] if group_col is not None else None
        same = (val == current_val) and (group_col is None or group_val == current_group)
        if not same:
            # merge si plus d'une ligne
            if i - 1 > start_idx:
                ws.merge_cells(
                    start_row=start_row + start_idx,
                    start_column=col_idx,
                    end_row=start_row + i - 1,
                    end_column=col_idx
                )
            start_idx = i
            current_val = val
            current_group = group_val
    # dernier bloc
    i = len(df_col)
    if i - 1 > start_idx:
        ws.merge_cells(
            start_row=start_row + start_idx,
            start_column=col_idx,
            end_row=start_row + i - 1,
            end_column=col_idx
        )


def draw_border_lines_for_tim_blocks(ws, start_row, df_sorted, first_col, last_col):
    """
    Dessine une ligne (top + bottom) autour de chaque bloc TIM.
    - start_row : ligne excel où commencent les données (entête +1)
    - df_sorted : dataframe trié utilisé pour la génération (avec colonne 'TIM')
    - first_col, last_col : index des colonnes Excel sur lesquelles dessiner (1-indexed)
    """
    thin = Side(border_style="thin", color="000000")
    top_border = Border(top=thin)
    bottom_border = Border(bottom=thin)

    # calculer positions par TIM
    groups = df_sorted.groupby("TIM").apply(lambda x: (x.index.min(), x.index.max()))
    for tim, (start_idx, end_idx) in groups.items():
        top_row = start_row + start_idx
        bottom_row = start_row + end_idx

        # ligne du dessus : appliquer top border sur la ligne top_row
        for c in range(first_col, last_col + 1):
            cell = ws.cell(row=top_row, column=c)
            # préserver autres côtés
            cell.border = Border(
                left=cell.border.left,
                right=cell.border.right,
                top=top_border.top,
                bottom=cell.border.bottom
            )
        # ligne du dessous : bottom border sur bottom_row
        for c in range(first_col, last_col + 1):
            cell = ws.cell(row=bottom_row, column=c)
            cell.border = Border(
                left=cell.border.left,
                right=cell.border.right,
                top=cell.border.top,
                bottom=bottom_border.bottom
            )


def write_copy_with_values_to_patron(df, patron_path, output_path):
    """
    Écrit la copie du patron (output_path) avec les valeurs issues de df.
    Applique fusion conditionnelle (SITE/DMU par TIM) et ajoute des lignes
    (bordures haut/bas) encadrant chaque TIM.
    """
    copyfile(patron_path, output_path)
    wb = load_workbook(filename=str(output_path))
    ws = wb.active

    # trouver header
    header_row = None
    for r in range(1, 20):
        values = [(ws.cell(row=r, column=c).value or "").strip().lower()
                  for c in range(1, ws.max_column + 1)]
        if "tim" in values and "site" in values and "uma" in values:
            header_row = r
            break
    if not header_row:
        header_row = 1

    # mapping header -> col index
    name_to_col = {}
    for c in range(1, ws.max_column + 1):
        v = ws.cell(row=header_row, column=c).value
        if v:
            name_to_col[v.strip().lower()] = c

    col_tim = name_to_col.get("tim")
    col_site = name_to_col.get("site")
    col_uma = name_to_col.get("uma")
    col_dmu = name_to_col.get("dmu")
    col_rum_mois = name_to_col.get("rum du mois")
    col_rum_cum = name_to_col.get("rum cumulés")
    if not all([col_tim, col_site, col_uma, col_dmu, col_rum_mois, col_rum_cum]):
        raise KeyError("Colonnes TIM, SITE, UMA, DMU ou RUM absentes dans le patron")

    start = header_row + 1

    # trier et réindexer pour mapping ligne->excel facile
    df_sorted = df.sort_values(by=["TIM", "SITE", "DMU", "UMA"]).reset_index(drop=True)

    # écrire valeurs brutes
    for idx, row in df_sorted.iterrows():
        excel_row = start + idx
        ws.cell(row=excel_row, column=col_tim).value = row["TIM"]
        ws.cell(row=excel_row, column=col_site).value = row["SITE"]
        ws.cell(row=excel_row, column=col_uma).value = row["UMA"]
        ws.cell(row=excel_row, column=col_dmu).value = row["DMU"]
        ws.cell(row=excel_row, column=col_rum_mois).value = int(row["RUM du mois"])
        ws.cell(row=excel_row, column=col_rum_cum).value = int(row["RUM cumulés"])

    # fusion verticale conditionnelle:
    # - TIM : fusionne quand TIM identique (sur lignes consécutives)
    # - SITE : fusionne quand SITE identique ET TIM identique
    # - DMU : fusionne quand DMU identique ET TIM identique
    merge_vertical_conditionnel(ws, col_tim, df_sorted["TIM"], start)
    merge_vertical_conditionnel(ws, col_site, df_sorted["SITE"], start, group_col=df_sorted["TIM"])
    merge_vertical_conditionnel(ws, col_dmu, df_sorted["DMU"], start, group_col=df_sorted["TIM"])

    # regrouper positions TIM et écrire sommes RUM (en première ligne du bloc TIM)
    rum_sums = df.groupby("TIM")[["RUM du mois", "RUM cumulés"]].sum().to_dict('index')
    tim_positions = df_sorted.groupby("TIM").apply(lambda x: (x.index.min(), x.index.max()))
    for tim, (start_idx, end_idx) in tim_positions.items():
        excel_row = start + start_idx
        ws.cell(row=excel_row, column=col_rum_mois).value = int(rum_sums[tim]["RUM du mois"])
        ws.cell(row=excel_row, column=col_rum_cum).value = int(rum_sums[tim]["RUM cumulés"])
        # fusion verticale pour les deux cellules RUM si plusieurs lignes pour le TIM
        if end_idx > start_idx:
            ws.merge_cells(start_row=excel_row, start_column=col_rum_mois,
                           end_row=start + end_idx, end_column=col_rum_mois)
            ws.merge_cells(start_row=excel_row, start_column=col_rum_cum,
                           end_row=start + end_idx, end_column=col_rum_cum)

    # dessiner les bordures LIGNES (top + bottom) autour de chaque TIM
    first_col = 1
    last_col = ws.max_column
    draw_border_lines_for_tim_blocks(ws, start, df_sorted, first_col, last_col)

    wb.save(output_path)
