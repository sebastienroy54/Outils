try:
    res = pd.DataFrame(rows).drop_duplicates()

    # Génère un identifiant de paire stable (une paire = 2 lignes dans l’Excel)
    # Ici : un ID simple basé sur l’index (suffisant pour usage Excel)
    res = res.reset_index(drop=True)
    res["PAIR_ID"] = res.index + 1  # 1,2,3...

    def build_rows_instead_of_columns(df_rel, keep_ghm: bool):
        """
        Transforme un DF relationnel (NDA1...NDA2...) en format lignes :
        2 lignes par relation + colonne COMMENTAIRE vide.
        """
        # LIGNE "séjour 1"
        left_cols = {
            "IPP": "IPP",
            "DATE_NAISSANCE": "DATE_NAISSANCE",
            "NDA": "NDA1",
            "UMA": "UMA1",
            "DATE_ENTREE": "DATEE1",
            "DATE_SORTIE": "DATES1",
            "PAIR_ID": "PAIR_ID"
        }
        if keep_ghm:
            left_cols["GHM"] = "GHM1"

        df1 = df_rel[list(left_cols.values())].copy()
        df1.columns = list(left_cols.keys())
        df1["LIGNE"] = 1

        # LIGNE "séjour 2"
        right_cols = {
            "IPP": "IPP",
            "DATE_NAISSANCE": "DATE_NAISSANCE",
            "NDA": "NDA2",
            "UMA": "UMA2",
            "DATE_ENTREE": "DATEE2",
            "DATE_SORTIE": "DATES2",
            "PAIR_ID": "PAIR_ID"
        }
        if keep_ghm:
            right_cols["GHM"] = "GHM2"

        df2 = df_rel[list(right_cols.values())].copy()
        df2.columns = list(right_cols.keys())
        df2["LIGNE"] = 2

        out = pd.concat([df1, df2], ignore_index=True)

        # Formatage dates dd/mm/yyyy
        for c in ["DATE_ENTREE", "DATE_SORTIE"]:
            out[c] = pd.to_datetime(out[c], errors="coerce").dt.strftime("%d/%m/%Y")

        # Colonne commentaire à remplir par les utilisateurs
        out["COMMENTAIRE"] = ""

        # Réorganisation colonnes
        if keep_ghm:
            out = out[["IPP", "DATE_NAISSANCE", "PAIR_ID", "LIGNE", "NDA", "UMA", "GHM",
                       "DATE_ENTREE", "DATE_SORTIE", "COMMENTAIRE"]]
        else:
            out = out[["IPP", "DATE_NAISSANCE", "PAIR_ID", "LIGNE", "NDA", "UMA",
                       "DATE_ENTREE", "DATE_SORTIE", "COMMENTAIRE"]]

        # Tri pour lecture
        out = out.sort_values(["IPP", "PAIR_ID", "LIGNE"]).reset_index(drop=True)
        return out

    with pd.ExcelWriter(OUTPUT_PATH, engine="openpyxl") as writer:
        for groupe in ["VRAI_DOUBLON", "DOUBLON_0_NUIT", "CONTIGUS", "CHEVAUCHEMENT"]:
            subset = res[res["TYPE_RELATION"] == groupe].copy()

            # On enlève la colonne interne TYPE_RELATION (pas d’export)
            subset = subset.drop(columns=["TYPE_RELATION"], errors="ignore")

            keep_ghm = (groupe == "CONTIGUS")

            if subset.empty:
                # Patron vide
                if keep_ghm:
                    df_to_write = pd.DataFrame([{
                        "IPP": "N/A", "DATE_NAISSANCE": "N/A", "PAIR_ID": "N/A", "LIGNE": "N/A",
                        "NDA": "N/A", "UMA": "N/A", "GHM": "N/A",
                        "DATE_ENTREE": "N/A", "DATE_SORTIE": "N/A", "COMMENTAIRE": ""
                    }])
                else:
                    df_to_write = pd.DataFrame([{
                        "IPP": "N/A", "DATE_NAISSANCE": "N/A", "PAIR_ID": "N/A", "LIGNE": "N/A",
                        "NDA": "N/A", "UMA": "N/A",
                        "DATE_ENTREE": "N/A", "DATE_SORTIE": "N/A", "COMMENTAIRE": ""
                    }])
            else:
                df_to_write = build_rows_instead_of_columns(subset, keep_ghm=keep_ghm)

            df_to_write.to_excel(writer, sheet_name=groupe, index=False)

            # Ajuste largeur des colonnes
            ws = writer.sheets[groupe]
            for i, col in enumerate(df_to_write.columns):
                max_len = max(df_to_write[col].astype(str).map(len).max(), len(col)) + 2
                ws.column_dimensions[ws.cell(row=1, column=i + 1).column_letter].width = max_len

except Exception as e:
    st.error(f"Erreur écriture Excel : {e}")
    return
