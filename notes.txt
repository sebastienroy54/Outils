import streamlit as st
import pandas as pd
import subprocess
import time
from pathlib import Path
from datetime import datetime
from openpyxl import load_workbook
from shutil import copyfile
import re

# ----------------- Configuration chemins -----------------
BASE_DIR = Path("C:/Users/4251352/Portail_outils")
DATA_DIR = BASE_DIR / "data"
SQL_DIR = BASE_DIR / "SQL"
PATRON_TIM_XLSX = DATA_DIR / "tableau_rum_tim.xlsx"  # Pour extraire la liste des TIM
PATRON_FILL_XLSX = DATA_DIR / "Tableau.xlsx"         # Patron Ã  copier et remplir

TNS_MAP = {
    "CCH": "SIP1CCH.WORLD",
    "BRC": "SIP1BRC.WORLD",
    "HTD": "SIP_HTD.WORLD"
}

# ----------------- Gestion des exceptions -----------------
def safe_show_exception(e):
    """Affiche un message d'erreur gÃ©nÃ©rique et permet de voir les dÃ©tails si cochÃ©."""
    st.session_state.last_exception_str = str(e)
    st.error("Une erreur est survenue. VÃ©rifiez vos fichiers ou contactez le support.")

    if "show_exception" not in st.session_state:
        st.session_state.show_exception = False

    st.session_state.show_exception = st.checkbox(
        "Afficher dÃ©tails techniques",
        value=st.session_state.show_exception
    )

    if st.session_state.show_exception and "last_exception_str" in st.session_state:
        st.code(st.session_state.last_exception_str)

# ----------------- Fonctions utilitaires -----------------
def run_sqlplus_and_wait(cmd, timeout=30):
    proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    start = time.time()
    output = ""
    while True:
        if proc.poll() is not None:
            out, _ = proc.communicate()
            output += (out or "")
            break
        if time.time() - start > timeout:
            proc.kill()
            raise TimeoutError("Timeout lors de l'exÃ©cution de sqlplus.")
        time.sleep(0.1)
    return output

def build_sql_spool_rum(site_label, file_spool_path, mode, month, year):
    if mode == "mois":
        start = f"01/{int(month):02d}/{year}"
        end_expr = f"LAST_DAY(TO_DATE('01/{int(month):02d}/{year}','DD/MM/YYYY'))"
        where_clause = (f"D8EEUE BETWEEN TO_DATE('{start}','DD/MM/YYYY') "
                        f"AND {end_expr}")
    else:
        start = f"01/01/{year}"
        end_expr = f"LAST_DAY(TO_DATE('01/{int(month):02d}/{year}','DD/MM/YYYY'))"
        where_clause = (f"D8SOUE >= TO_DATE('{start}','DD/MM/YYYY') "
                        f"AND D8EEUE <= {end_expr}")
    sql = f"""
SET HEADING OFF
SET FEEDBACK OFF
SET PAGESIZE 0
SET LINESIZE 2000
SET TRIMSPOOL ON
spool {file_spool_path}
SELECT CDURM_P || ';' || COUNT(*)
FROM EPI
WHERE {where_clause}
GROUP BY CDURM_P;
spool off
exit;
"""
    return sql

def read_spool_csv_to_df(spool_path):
    p = Path(spool_path)
    if not p.exists():
        return pd.DataFrame(columns=["UMA", "COUNT"])
    try:
        df = pd.read_csv(p, sep=';', header=None, dtype=str, names=["UMA", "COUNT"], engine="python")
        df["UMA"] = df["UMA"].astype(str).str.strip()
        df["COUNT"] = pd.to_numeric(df["COUNT"].astype(str).str.strip().replace("", "0"), errors="coerce").fillna(0).astype(int)
        return df
    except Exception:
        lines = p.read_text(encoding="utf-8", errors="ignore").splitlines()
        rows = []
        for line in lines:
            if ";" in line:
                a, b = line.split(";", 1)
                rows.append({"UMA": a.strip(), "COUNT": int(b.strip() or 0)})
        return pd.DataFrame(rows)

# ----------------- Fonctions TIM/UMA/DMU -----------------
def extract_uma_code_by_space(uma):
    if not isinstance(uma, str):
        return ""
    s = uma.strip()
    return s.split(" ", 1)[0].strip() if s else ""

def split_tims(cell):
    if not isinstance(cell, str):
        return []
    cell = cell.strip()
    if cell.lower() in {"nan", "none", ""}:
        return []
    parts = re.split(r'[/;,|]+', cell)
    return [p.strip() for p in parts if p.strip()]

def normalize_dmu(raw):
    if not isinstance(raw, str):
        return ""
    s = raw.strip()
    return s.split(" ", 1)[0].strip() if s else ""

def build_tim_uma_dict(patron_path):
    df = pd.read_excel(patron_path, engine="openpyxl", dtype=str)
    df.columns = [c.strip() for c in df.columns]

    for col in ["Site", "UMA", "DMU"]:
        if col not in df.columns:
            raise KeyError(f"Colonne manquante : {col}")

    tim_ref_col = "TIM RÃ©fÃ©rent" if "TIM RÃ©fÃ©rent" in df.columns else None
    relance_col = "Relance" if "Relance" in df.columns else None

    result = {}
    for _, row in df.iterrows():
        raw_uma = row.get("UMA", "")
        if not isinstance(raw_uma, str) or raw_uma.strip() == "" or raw_uma.startswith("Total DMU"):
            continue
        uma_code = extract_uma_code_by_space(raw_uma)
        site = str(row.get("Site", "")).strip() or "UNKNOWN"
        raw_dmu = row.get("DMU", "")
        dmu_code = normalize_dmu(raw_dmu)
        if dmu_code == "":
            continue

        tims = []
        if tim_ref_col:
            tims += split_tims(row.get(tim_ref_col, ""))
        if relance_col:
            tims += split_tims(row.get(relance_col, ""))

        if not tims:
            continue

        for tim in tims:
            tim_norm = re.sub(r'\s+', ' ', tim).strip()
            if not tim_norm:
                continue
            result.setdefault(tim_norm, {}).setdefault(site, {}).setdefault(dmu_code, set()).add(uma_code)

    # Convert sets to sorted lists
    result_listified = {
        tim: {
            site: {dmu: sorted(list(umas)) for dmu, umas in dmus.items()}
            for site, dmus in sites.items()
        }
        for tim, sites in result.items()
    }
    return result_listified

# ----------------- Fonction Excel -----------------
def write_copy_with_values_to_patron(df, patron_path, output_path):
    copyfile(patron_path, output_path)
    wb = load_workbook(filename=str(output_path))
    ws = wb.active

    # En-tÃªtes
    header_row = None
    for r in range(1, 20):
        values = [(ws.cell(row=r, column=c).value or "").strip().lower()
                  for c in range(1, ws.max_column + 1)]
        if "tim" in values and "site" in values and "uma" in values:
            header_row = r
            break
    if not header_row:
        header_row = 1

    # Mapper colonnes
    name_to_col = {ws.cell(row=header_row, column=c).value.strip().lower(): c
                   for c in range(1, ws.max_column + 1) if ws.cell(row=header_row, column=c).value}

    col_tim = name_to_col.get("tim")
    col_site = name_to_col.get("site")
    col_uma = name_to_col.get("uma")
    col_dmu = name_to_col.get("dmu")
    col_rum_mois = name_to_col.get("rum du mois")
    col_rum_cum = name_to_col.get("rum cumulÃ©s")
    if not all([col_tim, col_site, col_uma, col_dmu, col_rum_mois, col_rum_cum]):
        raise KeyError("Colonnes TIM, SITE, UMA, DMU ou RUM absentes dans le patron")

    start_row = header_row + 1

    # Somme des RUM par TIM
    rum_sums = df.groupby("TIM")[["RUM du mois", "RUM cumulÃ©s"]].sum().to_dict('index')

    # Tri
    df_sorted = df.sort_values(by=["TIM", "SITE", "DMU", "UMA"]).reset_index(drop=True)

    # Ã‰criture
    for idx, row in df_sorted.iterrows():
        excel_row = start_row + idx
        ws.cell(row=excel_row, column=col_tim).value = row["TIM"]
        ws.cell(row=excel_row, column=col_site).value = row["SITE"]
        ws.cell(row=excel_row, column=col_uma).value = row["UMA"]
        ws.cell(row=excel_row, column=col_dmu).value = row["DMU"]
        ws.cell(row=excel_row, column=col_rum_mois).value = row["RUM du mois"]
        ws.cell(row=excel_row, column=col_rum_cum).value = row["RUM cumulÃ©s"]

    # Fusion verticale
    def merge_vertical(col_idx, df_col):
        start_idx = 0
        current_val = df_col.iloc[0]
        for i, val in enumerate(df_col):
            if val != current_val or i == len(df_col) - 1:
                end_idx = i if val != current_val else i
                if end_idx > start_idx:
                    ws.merge_cells(
                        start_row=start_row + start_idx,
                        start_column=col_idx,
                        end_row=start_row + end_idx - 1,
                        end_column=col_idx
                    )
                start_idx = i
                current_val = val

    merge_vertical(col_tim, df_sorted["TIM"])
    merge_vertical(col_site, df_sorted["SITE"])
    merge_vertical(col_dmu, df_sorted["DMU"])

    # RUM fusionnÃ©es par TIM
    tim_positions = df_sorted.groupby("TIM").apply(lambda x: (x.index.min(), x.index.max()))
    for tim, (start_idx, end_idx) in tim_positions.items():
        excel_row = start_row + start_idx
        ws.cell(row=excel_row, column=col_rum_mois).value = int(rum_sums[tim]["RUM du mois"])
        ws.cell(row=excel_row, column=col_rum_cum).value = int(rum_sums[tim]["RUM cumulÃ©s"])
        if end_idx > start_idx:
            ws.merge_cells(start_row=excel_row, start_column=col_rum_mois,
                           end_row=start_row + end_idx, end_column=col_rum_mois)
            ws.merge_cells(start_row=excel_row, start_column=col_rum_cum,
                           end_row=start_row + end_idx, end_column=col_rum_cum)

    wb.save(output_path)

# ----------------- Pages Streamlit -----------------
def page_connexion():
    st.title("Connexion Oracle")
    if not st.session_state.logged_in:
        with st.form("connexion"):
            st.subheader("Connexion Oracle")
            user = st.text_input("ðŸ‘¤ Nom d'utilisateur Oracle :", key="conn_user")
            password = st.text_input("ðŸ”‘ Mot de passe :", type="password", key="conn_pwd")
            submitted = st.form_submit_button("ðŸš€ Se connecter")

        if submitted:
            if not user or not password:
                st.error("Veuillez renseigner vos identifiants Oracle.")
                return
            try:
                st.info("Test de connexion...")
                tns_alias = TNS_MAP["CCH"]
                test_sql_path = SQL_DIR / "test_connexion.sql"
                test_sql_path.write_text("select 1 from dual;\nexit;", encoding="utf-8")
                cmd = f"sqlplus -S {user}/{password}@{tns_alias} @{test_sql_path}"
                out = run_sqlplus_and_wait(cmd, timeout=3)
                if "1" in out:
                    st.session_state.oracle_connected = True
                    st.session_state.logged_in = True
                    st.session_state.oracle_user = user
                    st.session_state.oracle_password = password
                    st.session_state.page = "rum"
                    st.rerun()
                else:
                    st.error("Connexion Ã©chouÃ©e. VÃ©rifiez vos identifiants Oracle.")
            except Exception as e:
                safe_show_exception(e)
            finally:
                try:
                    test_sql_path.unlink()
                except:
                    pass
    else:
        st.success("Connexion active.")
        if st.button("âž¡ Aller Ã  la page RUM"):
            st.session_state.page = "rum"
            st.rerun()

def page_rum():
    st.title("Remplissage RUM â€” TIM")
    if "oracle_connected" not in st.session_state or not st.session_state.oracle_connected:
        st.error("Vous devez d'abord vous connecter sur la page Connexion.")
        return

    mois = st.selectbox("Choisir le mois", list(range(1, 13)), index=datetime.now().month - 1)
    annees = list(range(2013, datetime.now().year + 1))
    annee = st.selectbox("Choisir l'annÃ©e", annees, index=len(annees)-1)
    bouton = st.button("Lancer le traitement RUM")
    st.markdown("**Remarque :** le script va interroger les 3 TNS (CCH, BRC, HTD) et gÃ©nÃ©rer un tableau par TIM.")
    st.info(f"Fichiers lus/Ã©crits dans : `{DATA_DIR}`")
    if not bouton:
        return

    try:
        progress = st.progress(0)
        progress.progress(5)
        if not PATRON_TIM_XLSX.exists():
            st.error(f"Fichier TIM introuvable : {PATRON_TIM_XLSX}")
            return

        # Construction dictionnaire TIM
        tim_dict = build_tim_uma_dict(PATRON_TIM_XLSX)

        # GÃ©nÃ©rer DataFrame pour Excel
        rows = []
        for tim, sites in tim_dict.items():
            for site, dmus in sites.items():
                for dmu, umas in dmus.items():
                    for uma in umas:
                        rows.append({
                            "TIM": tim,
                            "SITE": site,
                            "DMU": dmu,
                            "UMA": uma,
                            "RUM du mois": 0,
                            "RUM cumulÃ©s": 0
                        })
        df_patron = pd.DataFrame(rows)
        progress.progress(30)

        # Ici tu peux intÃ©grer la logique d'extraction des RUM depuis SQL

        # Remplir la copie du patron
        sortie_path = DATA_DIR / f"tableau_rum_tim_rempli_{mois:02d}_{annee}.xlsx"
        write_copy_with_values_to_patron(df_patron, PATRON_FILL_XLSX, sortie_path)
        progress.progress(100)
        st.success(f"Traitement terminÃ© â€” fichier prÃªt au tÃ©lÃ©chargement : {sortie_path.name}")
        with open(sortie_path, "rb") as f:
            st.download_button(
                "TÃ©lÃ©charger le fichier rempli",
                data=f.read(),
                file_name=sortie_path.name,
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )

    except Exception as e:
        safe_show_exception(e)

# ----------------- Session -----------------
def ensure_session_vars():
    defaults = {
        "logged_in": False,
        "oracle_connected": False,
        "page": "connexion",
        "oracle_user": "",
        "oracle_password": "",
        "show_exception": False,
        "last_exception_str": ""
    }
    for k, v in defaults.items():
        if k not in st.session_state:
            st.session_state[k] = v

# ----------------- Main -----------------
def main():
    st.set_page_config(page_title="RUM TIM", layout="centered")
    ensure_session_vars()
    if st.session_state.page == "connexion":
        page_connexion()
    elif st.session_state.page == "rum":
        if not st.session_state.logged_in:
            st.session_state.page = "connexion"
            st.rerun()
        page_rum()
    else:
        st.session_state.page = "connexion"
        st.rerun()

if __name__ == "__main__":
    main()
